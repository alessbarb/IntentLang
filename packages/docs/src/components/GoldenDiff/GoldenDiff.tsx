import React, { useMemo } from "react";

type Props = {
  title?: string;
  il?: string;
  ts?: string;
  ilRaw?: string;
  tsRaw?: string;
  target: "ts";
  stripPrologue?: boolean;
  equivalences?: Array<(s: string) => string>;
  leftEquivalences?: Array<(s: string) => string>;
  rightEquivalences?: Array<(s: string) => string>;
  viewerHeight?: number; // <- expuesto
};

// -------------------- Normalización / utilidades -----------------------------

const stripTrailingSemicolon = (s: string) => s.trim().replace(/;$/, "");
const normalizeCommon = (s: string) =>
  s.replace(/\r/g, "").replace(/\t/g, "  ").replace(/ +$/gm, "").trim();

/** Equivalencias típicas IL ↔ TS para comparar “lo mismo con otra forma”. */
function normalizeSemantic(line: string): string {
  let s = normalizeCommon(line);

  s = stripTrailingSemicolon(s);

  // brand<Id>(expr) ≈ (expr as Id)
  s = s.replace(
    /\bbrand\s*<\s*([A-Za-z_][A-Za-z0-9_]*)\s*>\s*\(\s*([^)]+?)\s*\)/g,
    "($2 as $1)",
  );

  // { x } ≈ { x: x } — SOLO en una línea (no cruzar bloques)
  s = s.replace(
    /{([^\n\r{}]+)}/g,
    (m, inner) =>
      "{" +
      inner
        .split(",")
        .map((part) => {
          const p = part.trim();
          if (/^[A-Za-z_][A-Za-z0-9_]*\s*:/.test(p)) return p;
          if (/^[A-Za-z_][A-Za-z0-9_]*$/.test(p)) return `${p}: ${p}`;
          return p;
        })
        .join(", ") +
      "}",
  );

  s = s.replace(/'/g, '"');
  s = s.replace(/\s*:\s*/g, ": ").replace(/\s*=>\s*/g, " => ");
  return s;
}

function stripHeaders(text: string, lang: "il" | "ts"): string {
  if (!text) return text;
  const lines = text.split(/\r?\n/);
  const out: string[] = [];
  for (const ln of lines) {
    const t = ln.trim();
    if (lang === "ts") {
      if (/^\/\/\s*Generated by IntentLang/i.test(t)) continue;
      if (/^\/\/\s*DO NOT EDIT MANUALLY/i.test(t)) continue;
      if (/^import\s+(?:type\s+)?{.*}\s+from\s+["']\.\/_prelude["'];?/.test(t))
        continue;
    }
    out.push(ln);
  }
  return out
    .join("\n")
    .replace(/\n{3,}/g, "\n\n")
    .trim();
}

// ------------------------- Alineación (LCS por líneas) -----------------------

type DiffRow =
  | { tag: "match"; a: string; b: string }
  | { tag: "leftOnly"; a: string }
  | { tag: "rightOnly"; b: string };

function lcsCompare(aLines: string[], bLines: string[]): DiffRow[] {
  const n = aLines.length,
    m = bLines.length;
  const dp: number[][] = Array.from({ length: n + 1 }, () =>
    Array(m + 1).fill(0),
  );
  const eq = (x: string, y: string) =>
    normalizeSemantic(x) === normalizeSemantic(y);

  for (let i = n - 1; i >= 0; i--) {
    for (let j = m - 1; j >= 0; j--) {
      dp[i][j] = eq(aLines[i], bLines[j])
        ? dp[i + 1][j + 1] + 1
        : Math.max(dp[i + 1][j], dp[i][j + 1]);
    }
  }

  const rows: DiffRow[] = [];
  let i = 0,
    j = 0;
  while (i < n && j < m) {
    if (eq(aLines[i], bLines[j])) {
      rows.push({ tag: "match", a: aLines[i], b: bLines[j] });
      i++;
      j++;
    } else if (dp[i + 1][j] >= dp[i][j + 1]) {
      rows.push({ tag: "leftOnly", a: aLines[i++] });
    } else {
      rows.push({ tag: "rightOnly", b: bLines[j++] });
    }
  }
  while (i < n) rows.push({ tag: "leftOnly", a: aLines[i++] });
  while (j < m) rows.push({ tag: "rightOnly", b: bLines[j++] });
  return rows;
}

// ------------------------------ Componente -----------------------------------

export default function GoldenCompare({
  title,
  il,
  ts,
  ilRaw,
  tsRaw,
  target,
  stripPrologue = true,
  equivalences = [],
  leftEquivalences = [],
  rightEquivalences = [],
  viewerHeight = 480, // <- aquí el default
}: Props) {
  const ilCode0 = (il ?? ilRaw ?? "").trim();
  const tsCode0 = (ts ?? tsRaw ?? "").trim();
  const rhs0 = target === "ts" ? tsCode0 : "";

  const ilCode = stripPrologue ? stripHeaders(ilCode0, "il") : ilCode0;
  const tsCode = stripPrologue ? stripHeaders(rhs0, "ts") : rhs0;

  const leftFns = [...equivalences, ...leftEquivalences];
  const rightFns = [...equivalences, ...rightEquivalences];

  const origA = useMemo(() => ilCode.split(/\r?\n/), [ilCode]);
  const origB = useMemo(() => tsCode.split(/\r?\n/), [tsCode]);

  const normA = useMemo(
    () =>
      origA.map((ln) =>
        [...equivalences, ...leftEquivalences].reduce((acc, f) => f(acc), ln),
      ),
    [origA, equivalences, leftEquivalences],
  );
  const normB = useMemo(
    () =>
      origB.map((ln) =>
        [...equivalences, ...rightEquivalences].reduce((acc, f) => f(acc), ln),
      ),
    [origB, equivalences, rightEquivalences],
  );

  type Row =
    | { tag: "match"; a: string; b: string }
    | { tag: "leftOnly"; a: string }
    | { tag: "rightOnly"; b: string };

  function lcsCompareBy(
    origA: string[],
    origB: string[],
    normA: string[],
    normB: string[],
  ): Row[] {
    const n = normA.length,
      m = normB.length;
    const dp: number[][] = Array.from({ length: n + 1 }, () =>
      Array(m + 1).fill(0),
    );
    const eq = (i: number, j: number) =>
      normalizeSemantic(normA[i]) === normalizeSemantic(normB[j]);

    for (let i = n - 1; i >= 0; i--) {
      for (let j = m - 1; j >= 0; j--) {
        dp[i][j] = eq(i, j)
          ? dp[i + 1][j + 1] + 1
          : Math.max(dp[i + 1][j], dp[i][j + 1]);
      }
    }

    const rows: Row[] = [];
    let i = 0,
      j = 0;
    while (i < n && j < m) {
      if (eq(i, j)) {
        rows.push({ tag: "match", a: origA[i], b: origB[j] }); // <- originales
        i++;
        j++;
      } else if (dp[i + 1][j] >= dp[i][j + 1]) {
        rows.push({ tag: "leftOnly", a: origA[i++] });
      } else {
        rows.push({ tag: "rightOnly", b: origB[j++] });
      }
    }
    while (i < n) rows.push({ tag: "leftOnly", a: origA[i++] });
    while (j < m) rows.push({ tag: "rightOnly", b: origB[j++] });
    return rows;
  }

  const rows = useMemo(
    () => lcsCompareBy(origA, origB, normA, normB),
    [origA, origB, normA, normB],
  );

  return (
    <div
      style={{
        border: "1px solid var(--ifm-toc-border-color, #e6e6e6)",
        borderRadius: 12,
        overflow: "hidden",
        margin: "16px 0 24px",
        boxShadow: "0 6px 24px rgba(0,0,0,0.05)",
      }}
    >
      <div
        style={{
          height: viewerHeight,
          overflow: "auto",
          borderRadius: 10,
        }}
      >
        {/* Cabecera sticky */}
        <div
          style={{
            position: "sticky",
            top: 0,
            zIndex: 1,
            display: "grid",
            gridTemplateColumns: "48px 1fr 48px 1fr",
            background: "var(--ifm-background-surface-color)",
            borderBottom: "1px solid rgba(0,0,0,0.08)",
            fontWeight: 600,
            padding: "8px 10px",
          }}
        >
          <div style={{ textAlign: "right", opacity: 0.7 }}>#</div>
          <div>IL{title ? ` — ${title}` : ""}</div>
          <div style={{ textAlign: "right", opacity: 0.7 }}>#</div>
          <div style={{ textAlign: "right" }}>TS (emit)</div>
        </div>

        {/* Filas */}
        <div>
          {rows.map((r, idx) => (
            <Row
              key={idx}
              idx={idx}
              leftText={r.tag === "rightOnly" ? "" : r.a}
              rightText={r.tag === "leftOnly" ? "" : r.b}
              kind={r.tag}
            />
          ))}
        </div>
      </div>

      {/* Leyenda fuera del scroll */}
      <FooterLegend />
    </div>
  );
}

// ---------------------------- Presentación -----------------------------------

function Row({
  idx,
  leftText,
  rightText,
  kind,
}: {
  idx: number;
  leftText: string;
  rightText: string;
  kind: DiffRow["tag"];
}) {
  const leftBg = kind === "leftOnly" ? "rgba(0,112,243,0.06)" : "transparent";
  const rightBg =
    kind === "rightOnly" ? "rgba(240,173,78,0.10)" : "transparent";

  const baseCell: React.CSSProperties = {
    padding: "6px 10px",
    whiteSpace: "pre-wrap",
    wordBreak: "break-word",
    borderBottom: "1px solid rgba(0,0,0,0.04)",
    fontFamily: "var(--ifm-font-family-monospace)",
    fontSize: "0.9rem",
    lineHeight: 1.45,
  };

  const numStyle: React.CSSProperties = {
    ...baseCell,
    paddingRight: 8,
    textAlign: "right",
    color: "var(--ifm-color-emphasis-600)",
    userSelect: "none",
  };

  return (
    <div style={{ display: "grid", gridTemplateColumns: "48px 1fr 48px 1fr" }}>
      <div style={numStyle}>{idx + 1}</div>
      <div style={{ ...baseCell, background: leftBg }}>{leftText}</div>
      <div style={numStyle}>{idx + 1}</div>
      <div style={{ ...baseCell, background: rightBg }}>{rightText}</div>
    </div>
  );
}

function FooterLegend() {
  const item = (color: string, label: string) => (
    <span>
      <span
        style={{
          display: "inline-block",
          width: 10,
          height: 10,
          background: color,
          border: "1px solid rgba(0,0,0,0.15)",
          marginRight: 6,
          verticalAlign: "-2px",
        }}
      />
      {label}
    </span>
  );
  return (
    <div
      style={{
        display: "flex",
        gap: 16,
        padding: "8px 12px",
        fontSize: 12,
        color: "var(--ifm-color-emphasis-700)",
        borderTop: "1px solid var(--ifm-toc-border-color, #e6e6e6)",
        background: "var(--ifm-background-surface-color)",
      }}
      aria-label="Leyenda"
    >
      {item("rgba(0, 112, 243, 0.18)", "Solo IL")}
      {item("rgba(240, 173, 78, 0.25)", "Solo TS")}
      {item("transparent", "Equivalente")}
    </div>
  );
}
