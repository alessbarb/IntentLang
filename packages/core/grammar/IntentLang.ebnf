(* =================================================== *)
(* ===== Directivas para el generador de .g4 ========= *)
(* =================================================== *)

%keywords:
  module, from, as,
  intent, tags, uses, types, type, where,
  func, effect, test, const, let, brand,
  requires, ensures,
  return, if, else, match,
  for, in, while, break, continue,
  try, catch, throw,
  async, await, spawn,
  Ok, Err, Some, None,
  Array, Map,
  Unit, Bool, Int, Float, String, Bytes, Uuid, DateTime,
  fn,
  exports, imports
;

%punct:
  "||" OROR, "&&" ANDAND, "==" EQEQ, "!=" BANGEQ, "<=" LTE, ">=" GTE,
  "<<" LSHIFT, ">>" RSHIFT,
  "=>" FATARROW, "->" ARROW,
  "+=" PLUSEQ, "-=" MINUSEQ, "*=" STAREQ, "/=" SLASHEQ, "%=" PERCENTEQ,
  "|" OR, "^" CARET, "&" AMP, "<" LT, ">" GT,
  "+" PLUS, "-" MINUS, "*" STAR, "/" SLASH, "%" PERCENT,
  "!" BANG, "~" TILDE,
  "(" LPAREN, ")" RPAREN, "." DOT, "," COMMA, ":" COLON, ";" SEMI,
  "{" LBRACE, "}" RBRACE, "[" LBRACK, "]" RBRACK,
  "?" QMARK, "_" UNDERSCORE,
  "=" ASSIGN
;

%lexer {
  BOOL        : 'true' | 'false' ;
  IDENT       : [A-Za-z_] [A-Za-z0-9_]* ;
  STRING      : '"' ( '\\' . | ~["\\] )* '"' ;
  FLOAT       : '-'? [0-9]+ '.' [0-9]+ ;
  INT         : '-'? [0-9]+ ;
  LINE_COMMENT: '//' ~[\r\n]* -> skip ;
  BLOCK_COMMENT: '/*' .*? '*/' -> skip ;
  WS          : [ \t\r\n]+     -> skip ;
}

(* =================================================== *)
(* ============== Puentes léxicos ==================== *)
(* =================================================== *)

ident  = IDENT ;
string = STRING ;
int    = INT ;
float  = FLOAT ;
bool   = BOOL ;

(* =================================================== *)
(* ============== Gramática (parser) ================= *)
(* =================================================== *)

File             = [ ModuleHeader ] ,
                   [ ImportsSection ] ,
                   [ IntentSection ] ,
                   [ UsesSection ] ,
                   [ TypesSection ] ,
                   { TopLevelDecl } ,
                   [ ExportsSection ] ;

TopLevelDecl     = FuncDecl | EffectDecl | TopLevelConstDecl | TestDecl | TypeDecl ;

(* ======== Modules ======== *)
ModuleHeader     = "module" , ModulePath , [ "as" , ident ] , ";" ;
ModulePath       = ident , { "." , ident } ;

(* ===== Imports section ===== *)
ImportsSection   = "imports" , "{" , { FromImport } , "}" ;
FromImport       = "from" , ModulePath , ":" , ImportList , ";" ;
ImportList       = ImportEntry , { "," , ImportEntry } , [ "," ] ;
ImportEntry      = "*" , "as" , ident
                 | ident , [ "as" , ident ] ;

(* ========= Sections ========= *)
IntentSection    = "intent" , string , [ TagList ] ;
TagList          = "tags" , "[" , string , { "," , string } , "]" ;
UsesSection      = "uses" , "{" , { UseDecl } , "}" ;
UseDecl          = ident , ":" , ident , [ ObjectExpr ] , [ "," ] ;
TypesSection     = "types" , "{" , { TypeDecl } , "}" ;
TypeDecl         = "type" , ident , "=" , TypeExpr , [ "where" , RefinementExpr ] , ";" ;

(* ======== Exports Section ======== *)
ExportsSection   = "exports" , "{" , { ExportGroup | ExportItem } , "}" ;
ExportGroup      = ExportKind , ":" , ExportNameList , ";" ;
ExportKind       = "func" | "effect" | "type" | "const" ;
ExportNameList   = ExportName , { "," , ExportName } , [ "," ] ;
ExportName       = ident , [ "as" , ident ] ;
ExportItem       = ExportKind , ident , [ "as" , ident ] , ";" ;

(* ======== Type System ======== *)
TypeExpr         = UnionType | NonUnionType ;
NonUnionType     = RecordType | GenericType | BrandType | FuncType | ArrayType | MapType | TypeRef | BasicType | LiteralType ;
TypeRef          = ident | "(" , TypeExpr , ")" ;
UnionType        = [ "|" ] , UnionCtor , { "|" , UnionCtor } ;
UnionCtor        = ident , [ RecordType ] | LiteralType ;
RecordType       = "{" , [ FieldList ] , "}" ;
FieldList        = FieldDecl , { "," , FieldDecl } , [ "," ] ;
FieldDecl        = ident , ":" , TypeExpr , [ "where" , RefinementExpr ] ;
RefinementExpr   = FunctionCall | Comparison ;
FunctionCall     = ident , "(" , string , ")" ;
Comparison       = Accessor , CompareOp , Literal ;
Accessor         = ( ident | "_" ) , [ "." , ident ] ;
CompareOp        = "==" | "!=" | ">=" | "<=" | ">" | "<" ;
GenericType      = ident , "<" , TypeExpr , { "," , TypeExpr } , ">" ;
BrandType        = NonUnionType , "brand" , string ;
BasicType        = "Unit" | "Bool" | "Int" | "Float" | "String" | "Bytes" | "Uuid" | "DateTime" ;
LiteralType      = string ;
FuncType         = "(" , [ ParamTypeList ] , ")" , "->" , TypeExpr ;
ParamTypeList    = ParamType , { "," , ParamType } ;
ParamType        = [ ident , ":" ] , TypeExpr ;
ArrayType        = "Array" , "<" , TypeExpr , ">" ;
MapType          = "Map" , "<" , TypeExpr , "," , TypeExpr , ">" ;

(* ======= Declarations ======== *)
TopLevelConstDecl = "const" , ident , ":" , TypeExpr , "=" , Expr , ";" ;
FuncDecl         = "func" , ident , "(" , [ ParamList ] , ")" , ":" , TypeExpr , [ ContractBlock ] , Block ;
EffectDecl       = "effect" , ident , "(" , [ ParamList ] , ")" , ":" , TypeExpr , [ ContractBlock ] , "uses" , ident , { "," , ident } , Block ;
TestDecl         = "test" , ident , Block ;
ParamList        = Param , { "," , Param } ;
Param            = ident , ":" , TypeExpr ;
ContractBlock    = [ "requires" , Expr ] , [ "ensures" , Expr ] ;

(* ===== Statements/Blocks ===== *)
Block            = "{" , { Stmt } , "}" ;
Stmt             = LetStmt | ConstStmt | AssignStmt | UpdateStmt | ReturnStmt | IfStmt | MatchStmt | ForStmt | WhileStmt | TryStmt | BreakStmt | ContinueStmt | ExprStmt ;

LetStmt          = "let" , ident , ":" , TypeExpr , "=" , Expr , ";" ;
ConstStmt        = "const" , ident , ":" , TypeExpr , "=" , Expr , ";" ;
AssignStmt       = LValue , AssignOp , Expr , ";" ;
UpdateStmt       = LValue , ( "++" | "--" ) , ";" ;
LValue           = ident , { "." , ident | "[" , Expr , "]" } ;
AssignOp         = "=" | "+=" | "-=" | "*=" | "/=" | "%=" ;

ReturnStmt       = "return" , [ Expr ] , ";" ;
IfStmt           = "if" , Expr , Block , [ "else" , Block ] ;
MatchStmt        = MatchExpr , ";" ;
ForStmt          = "for" , ident , "in" , Expr , Block ;
WhileStmt        = "while" , Expr , Block ;
BreakStmt        = "break" , ";" ;
ContinueStmt     = "continue" , ";" ;
TryStmt          = "try" , Block , "catch" , "(" , ident , ")" , Block ;
ExprStmt         = Expr , ";" ;

(* ======= Expressions (lowest → highest precedence) ========= *)
Expr             = CondExpr ;
CondExpr         = OrExpr , [ "?" , Expr , ":" , Expr ] ;
OrExpr           = AndExpr , { "||" , AndExpr } ;
AndExpr          = BitOrExpr , { "&&" , BitOrExpr } ;
BitOrExpr        = BitXorExpr , { "|" , BitXorExpr } ;
BitXorExpr       = BitAndExpr , { "^" , BitAndExpr } ;
BitAndExpr       = EqualityExpr , { "&" , EqualityExpr } ;
EqualityExpr     = RelExpr , { ( "==" | "!=" ) , RelExpr } ;
RelExpr          = ShiftExpr , { ( "<" | "<=" | ">" | ">=" ) , ShiftExpr } ;
ShiftExpr        = AddExpr , { ( "<<" | ">>" ) , AddExpr } ;
AddExpr          = MulExpr , { ( "+" | "-" ) , MulExpr } ;
MulExpr          = UnaryExpr , { ( "*" | "/" | "%" ) , UnaryExpr } ;
UnaryExpr        = ( "!" | "-" | "~" | "await" | "spawn" | "throw" ) , UnaryExpr | PostfixExpr ;

PostfixExpr      = Primary , { "(" , [ ArgList ] , ")" | "." , ident | "[" , Expr , "]" } ;
ArgList          = Expr , { "," , Expr } ;

Primary          = Literal | ident | "(" , Expr , ")" | ObjectExpr | VariantExpr | ArrayExpr | MapExpr | MatchExpr | ResultOkExpr | ResultErrExpr | OptionSomeExpr | OptionNoneExpr | BrandCastExpr | LambdaExpr ;

LambdaExpr       = "fn" , "(" , [ TypedParamList ] , ")" , [ ":" , TypeExpr ] , "=>" , ( Expr | Block ) ;
TypedParamList   = TypedParam , { "," , TypedParam } ;
TypedParam       = ident , ":" , TypeExpr ;

(* ===== Compound literals ===== *)
ObjectExpr       = "{" , [ RecordFieldList ] , "}" ;
VariantExpr      = ident , ( "{" , [ RecordFieldList ] , "}" | "(" , [ ArgList ] , ")" ) ;
ArrayExpr        = "[" , [ Expr , { "," , Expr } ] , "]" ;
MapExpr          = "Map" , "{" , [ MapEntry , { "," , MapEntry } , [ "," ] ] , "}" ;
MapEntry         = "(" , Expr , ":" , Expr , ")" ;
MatchExpr        = "match" , Expr , "{" , { CaseClause } , "}" ;
RecordFieldList  = RecordField , { "," , RecordField } , [ "," ] ;
RecordField      = ident , [ ":" , Expr ] ;
ResultOkExpr     = "Ok" , "(" , Expr , ")" ;
ResultErrExpr    = "Err" , "(" , Expr , ")" ;
OptionSomeExpr   = "Some" , "(" , Expr , ")" ;
OptionNoneExpr   = "None" ;
BrandCastExpr    = "brand" , "<" , ident , ">" , "(" , Expr , ")" ;
CaseClause       = Pattern , [ "if" , Expr ] , "=>" , ( Expr | Block ) , ";" ;
Literal          = string | float | int | bool ;

(* ========= Patterns ========= *)
Pattern          = WildcardPattern | LiteralPattern | VariantPattern | RecordPattern | IdentPattern ;
WildcardPattern  = "_" ;
LiteralPattern   = Literal ;
VariantPattern   = ident , ( RecordPattern | "(" , [ PatternArgList ] , ")" )? ;
PatternArgList   = Pattern , { "," , Pattern } ;
RecordPattern    = "{" , [ PatternFieldList ] , "}" ;
PatternFieldList = PatternField , { "," , PatternField } , [ "," ] ;
PatternField     = ident , [ ":" , ident ] ;
IdentPattern     = ident ;
