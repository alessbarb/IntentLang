// packages/core/src/transpilers/python.ts
// Transpilador de IntentLang a Python v0.1

import type {
  Program,
  TypeDecl,
  TypeExpr,
  RecordType,
  BrandType,
  NamedType,
  BasicType,
  GenericType,
  UnionType,
  LiteralType,
  FuncDecl,
  EffectDecl,
  TestDecl,
  TestBlock,
  Block,
  ForStmt,
  Stmt,
  Expr,
  LiteralExpr,
  BinaryExpr,
  CallExpr,
  IdentifierExpr,
  UnaryExpr,
  UpdateExpr,
  AssignExpr,
  ConditionalExpr,
} from "../ast.js";
import { readFileSync } from "node:fs";
import { fileURLToPath } from "node:url";
import { dirname, resolve } from "node:path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const pkg = JSON.parse(
  readFileSync(resolve(__dirname, "../../package.json"), "utf8"),
) as { version: string };

// ---------- API Pública ----------
export function emitPython(program: Program): string {
  const out: string[] = [];
  out.push(`# Generated by IntentLang v${pkg.version}`);
  out.push(`# DO NOT EDIT MANUALLY\n`);

  out.push(runtimePrelude());

  // Types
  if (program.types) {
    // TODO: Implementar un sistema de ordenación de tipos basado en dependencias
    // en lugar de este enfoque simple de dos pasadas.
    // Primero, genera las clases para los records
    for (const t of program.types.declarations) {
      if (t.expr.kind === "RecordType") {
        out.push(recordToPy(t.name.name, t.expr));
      }
    }
    // Luego, el resto de los tipos
    for (const t of program.types.declarations) {
      if (t.expr.kind !== "RecordType") {
        out.push(emitTypeDecl(t));
      }
    }
    out.push("");
  }

  // Funcs, Effects & Tests
  for (const item of program.items) {
    if (item.kind === "FuncDecl") out.push(emitFunc(item));
    else if (item.kind === "EffectDecl") out.push(emitEffect(item));
    else if (item.kind === "TestDecl") out.push(emitTest(item));
  }

  return out.join("\n");
}

// ---------- Preludio de Runtime ----------
function runtimePrelude(): string {
  return `
from dataclasses import dataclass
from typing import Type, TypeVar, Generic, Union, Optional, NewType, Literal
from datetime import datetime

# --- Preludio de Tipos ---
T = TypeVar('T')
E = TypeVar('E')

@dataclass
class Ok(Generic[T]):
    value: T

@dataclass
class Err(Generic[E]):
    error: E

Result = Union[Ok[T], Err[E]]

# --- Capacidades (stubs) ---
# TODO: Generar stubs de capacidades basadas en la sección 'uses' del fichero .il
@dataclass
class Http:
    base_url: str
    timeout_ms: int

@dataclass
class Clock:
    pass

@dataclass
class Random:
    seed: int
`;
}

// ---------- Tipos ----------

function emitTypeDecl(t: TypeDecl): string {
  const typeName = t.name.name;
  const exprStr = pyType(t.expr, typeName);
  if (exprStr.startsWith("@dataclass")) {
    // Los records ya se manejan
    return "";
  }
  return `${typeName} = ${exprStr}`;
}

function pyType(t: TypeExpr, typeName?: string): string {
  switch (t.kind) {
    case "BasicType":
      return basicToPy(t);
    case "BrandType":
      // NewType es el equivalente más cercano en Python
      return `NewType('${t.brand}', ${basicToPy(t.base)})`;
    case "LiteralType":
      return `Literal[${JSON.stringify(t.value)}]`;
    case "RecordType":
      return recordToPy(typeName || "AnonymousRecord", t);
    case "GenericType":
      const params = t.params.map((p) => pyType(p)).join(", ");
      const genericName = t.name.name === "Result" ? "Result" : t.name.name;
      return `${genericName}[${params}]`;
    case "UnionType":
      const ctors = t.ctors
        .map((ctor) => {
          if (ctor.kind === "LiteralCtor") return pyType(ctor.literal);
          return ctor.name.name;
        })
        .join(", ");
      return `Union[${ctors}]`;
    case "NamedType":
      return t.name.name;
  }
}

function basicToPy(b: BasicType): string {
  switch (b.name) {
    case "Unit":
      return "None";
    case "Bool":
      return "bool";
    case "Int":
      return "int";
    case "Float":
      return "float";
    case "String":
    case "Uuid":
      return "str";
    case "Bytes":
      return "bytes";
    case "DateTime":
      return "datetime";
  }
}

function recordToPy(name: string, r: RecordType): string {
  // TODO: Añadir soporte para refinamientos de campo (cláusula 'where') como validadores en `__post_init__`.
  const fields = r.fields
    .map((f) => `    ${f.name.name}: ${pyType(f.type)}`)
    .join("\n");
  return `@dataclass\nclass ${name}:\n${fields || "    pass"}`;
}

// ---------- Declaraciones ----------

function emitFunc(fn: FuncDecl): string {
  const params = fn.params
    .map((p) => `${p.name.name}: ${pyType(p.type)}`)
    .join(", ");
  const ret = pyType(fn.returnType);
  let body = emitBlock(fn.body, 1);

  if (fn.contracts?.requires) {
    body = `    assert ${emitExpr(fn.contracts.requires)}, "Precondition failed"\n${body}`;
  }

  // TODO: Implementar la cláusula 'ensures'. Podría requerir decorar la función o inyectar aserciones antes de cada 'return'.

  return `def ${fn.name.name}(${params}) -> ${ret}:\n${body}\n`;
}

function emitEffect(eff: EffectDecl): string {
  const paramSigs = eff.params.map((p) => `${p.name.name}: ${pyType(p.type)}`);
  // TODO: Generar un dataclass para 'deps' basado en la cláusula 'uses' de este efecto.
  const params = ["deps", ...paramSigs].join(", ");
  const ret = pyType(eff.returnType);
  let body = emitBlock(eff.body, 1);

  if (eff.contracts?.requires) {
    body = `    assert ${emitExpr(eff.contracts.requires)}, "Precondition failed"\n${body}`;
  }

  // TODO: Implementar la cláusula 'ensures' para efectos.

  return `async def ${eff.name.name}(${params}) -> ${ret}:\n${body}\n`;
}

function emitTest(t: TestDecl): string {
  // TODO: Añadir el setup del runtime (initRuntime) y el paso de dependencias a los tests que usan efectos.
  const body = emitBlock(t.body, 1);
  return `def test_${t.name.name}():\n${body}\n`;
}

// ---------- Bloques y Sentencias ----------

function emitBlock(b: Block | TestBlock, indentLevel: number): string {
  const indent = "    ".repeat(indentLevel);
  if (b.statements.length === 0) return `${indent}pass`;
  return b.statements.map((s) => indent + emitStmt(s, indentLevel)).join("\n");
}

function emitStmt(s: Stmt, indentLevel: number): string {
  switch (s.kind) {
    case "LetStmt":
      return `${s.id.name} = ${emitExpr(s.init)}`;
    case "ReturnStmt":
      return `return ${s.argument ? emitExpr(s.argument) : "None"}`;
    case "ForStmt": {
      const it = s.iterator.name;
      const iterable = emitExpr(s.iterable);
      const body = emitBlock(s.body, indentLevel + 1);
      return `for ${it} in ${iterable}:\n${body}`;
    }
    case "ExprStmt":
      return emitExpr(s.expression);
    // TODO: Implementar la transpilación para 'IfStmt'.
    // TODO: Implementar la transpilación para 'MatchStmt' usando 'match/case' de Python.
    default:
      return `# Stmt type '${(s as any).kind}' not implemented`;
  }
}

// ---------- Expresiones ----------

function emitExpr(e: Expr): string {
  switch (e.kind) {
    case "IdentifierExpr":
      return e.id.name;
    case "LiteralExpr":
      const val = e.value.value;
      if (e.value.kind === "Bool") return val ? "True" : "False";
      return JSON.stringify(val);
    case "BinaryExpr":
      const opMap: Record<string, string> = { "&&": "and", "||": "or" };
      const op = opMap[e.op] || e.op;
      return `(${emitExpr(e.left)} ${op} ${emitExpr(e.right)})`;
    case "CallExpr":
      // TODO: Añadir lógica para manejar llamadas a capacidades (ej. `http.get(...)` -> `deps.http.get(...)`).
      const callee = emitExpr(e.callee);
      const args = e.args.map(emitExpr).join(", ");
      return `${callee}(${args})`;
    case "UnaryExpr":
      return `${e.op}${emitExpr(e.argument)}`;
    case "UpdateExpr": {
      // Limitación: solo soportamos actualizaciones sobre identificadores simples.
      if (e.argument.kind !== "IdentifierExpr") {
        return `# UpdateExpr sobre expresión no soportada`;
      }
      const name = e.argument.id.name;
      const delta = e.op === "++" ? "+= 1" : "-= 1";
      return `${name} ${delta}`;
    }
    case "AssignExpr":
      return `${emitExpr(e.left)} ${e.op} ${emitExpr(e.right)}`;
    case "ConditionalExpr":
      return `${emitExpr(e.consequent)} if ${emitExpr(e.test)} else ${emitExpr(e.alternate)}`;
    // TODO: Implementar el resto de los tipos de expresiones:
    // ObjectExpr, ArrayExpr, MemberExpr, ResultOkExpr, ResultErrExpr,
    // OptionSomeExpr, OptionNoneExpr, BrandCastExpr, VariantExpr, MatchExpr.
    default:
      return `# Expr type '${(e as any).kind}' not implemented`;
  }
}
