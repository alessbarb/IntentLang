// packages/core/src/transpilers/typescript.ts
// Transpiler v0.3 — soporta AST con items[], cuerpos de funciones/efectos,
// match exhaustivo (a TS con if/else), Ok/Err, Some/None y acceso a deps.*.

import type {
  Program,
  TypeDecl,
  TypeExpr,
  RecordType,
  BrandType,
  NamedType,
  BasicType,
  LiteralType,
  GenericType,
  FuncDecl,
  EffectDecl,
  TestDecl,
  TestBlock,
  Block,
  Stmt,
  LetStmt,
  ReturnStmt,
  IfStmt,
  MatchStmt,
  ExprStmt,
  Expr,
  IdentifierExpr,
  LiteralExpr,
  ObjectExpr,
  ArrayExpr,
  CallExpr,
  MemberExpr,
  UnaryExpr,
  BinaryExpr,
  ResultOkExpr,
  ResultErrExpr,
  OptionSomeExpr,
  OptionNoneExpr,
  BrandCastExpr,
  VariantExpr,
  MatchExpr,
  CaseClause,
  Pattern,
  VariantPattern,
  LiteralPattern,
} from "../ast.js";
import { readFileSync } from "node:fs";
import { fileURLToPath } from "node:url";
import { dirname, resolve } from "node:path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const pkg = JSON.parse(
  readFileSync(resolve(__dirname, "../../package.json"), "utf8"),
) as { version: string };

// ---------- Public API ----------
export function emitTypeScript(program: Program): string {
  const out: string[] = [];
  out.push(`// Generated by IntentLang v${pkg.version}`);
  out.push(`// DO NOT EDIT MANUALLY\n`);

  out.push(runtimePrelude());

  // Types
  if (program.types) {
    for (const t of program.types.declarations) {
      out.push(emitTypeDecl(t));
    }
    out.push("");
  }

  // Capabilities
  const usesDecl = program.uses?.entries ?? [];
  if (usesDecl.length) {
    out.push(`// Declared capabilities`);
    out.push(`export type Capabilities = {`);
    for (const u of usesDecl) {
      out.push(`  ${u.name.name}: ${u.typeName.name};`);
    }
    out.push(`};\n`);
  } else {
    out.push(`export type Capabilities = {};`);
    out.push("");
  }

  // Funcs, Effects & Tests
  for (const item of program.items) {
    if (item.kind === "FuncDecl") out.push(emitFunc(item));
    else if (item.kind === "EffectDecl") out.push(emitEffect(item));
    else if (item.kind === "TestDecl") out.push(emitTest(item));
  }

  return out.join("\n");
}

// ---------- Types ----------

function emitTypeDecl(t: TypeDecl): string {
  return `export type ${t.name.name} = ${tsType(t.expr)};`;
}

function tsType(t: TypeExpr): string {
  switch (t.kind) {
    case "BasicType":
      return basicToTs(t);
    case "BrandType":
      return `(${basicToTs(t.base)}) & Brand<"${t.brand}">`;
    case "LiteralType":
      return JSON.stringify(t.value);
    case "RecordType":
      return recordToTs(t);
    case "GenericType":
      return genericToTs(t);
    case "UnionType":
      return unionToTs(t);
    case "NamedType":
      return t.name.name;
  }
}

function basicToTs(b: BasicType): string {
  switch (b.name) {
    case "Bool":
      return "boolean";
    case "Int":
    case "Float":
      return "number";
    case "String":
      return "string";
    case "Bytes":
      return "Uint8Array";
    case "Uuid":
      return "string";
    case "DateTime":
      // Puedes cambiarlo a string si prefieres —en goldens lo usáis como Date o string indistintamente.
      return "Date";
  }
}

function recordToTs(r: RecordType): string {
  const fields = r.fields
    .map((f) => `  ${f.name.name}: ${tsType(f.type)};`)
    .join("\n");
  return `{\n${fields}\n}`;
}

function unionToTs(u: TypeExpr & { kind: "UnionType" }): string {
  // Convención de IL: unions discriminadas por `type: "<Ctor>"`
  // Literal unions: string|number|boolean literales
  const parts = u.ctors.map((c) => {
    if (c.kind === "LiteralCtor") {
      return JSON.stringify(c.literal.value);
    }
    const name = c.name.name;
    const payload =
      c.fields && c.fields.fields.length
        ? `, ${c.fields.fields
            .map((f) => `${f.name.name}: ${tsType(f.type)}`)
            .join(", ")} `
        : "";
    return `{ type: "${name}"${payload}}`;
  });
  // Si hay mezcla de literales y nombrados, TS quedará como unión heterogénea.
  return parts.join(" | ");
}

function genericToTs(g: GenericType): string {
  const params = g.params.map((p) => tsType(p)).join(", ");
  return `${g.name.name}<${params}>`;
}

// ---------- Decls ----------

function emitFunc(fn: FuncDecl): string {
  const paramsTs = fn.params
    .map((p) => `${p.name.name}: ${tsType(p.type)}`)
    .join(", ");
  const retTs = tsType(fn.returnType);
  const body = emitBlock(fn.body, /*isEffect*/ false);
  return `export function ${fn.name.name}(${paramsTs}): ${retTs} {\n${indent(body)}\n}\n`;
}

function emitEffect(eff: EffectDecl): string {
  const paramsTs = [
    "deps: Capabilities",
    ...eff.params.map((p) => `${p.name.name}: ${tsType(p.type)}`),
  ].join(", ");
  const retTs = tsType(eff.returnType);
  const body = emitBlock(eff.body, /*isEffect*/ true);
  return `export async function ${eff.name.name}(${paramsTs}): Promise<${retTs}> {\n${indent(body)}\n}\n`;
}

function emitTest(t: TestDecl): string {
  const body = emitBlock(t.body, /*isEffect*/ false);
  return `export async function test_${t.name.name}(): Promise<void> {\n${indent(body)}\n}\n`;
}

// ---------- Blocks & Statements ----------

function emitBlock(b: Block | TestBlock, isEffect: boolean): string {
  return b.statements.map((s) => emitStmt(s, isEffect)).join("\n");
}

function emitStmt(s: Stmt, isEffect: boolean): string {
  switch (s.kind) {
    case "LetStmt": {
      const init = emitExpr(s.init, isEffect);
      return `const ${s.id.name} = ${init};`;
    }
    case "ReturnStmt": {
      if (!s.argument) return `return;`;
      const e = emitExpr(s.argument, isEffect);
      return `return ${e};`;
    }
    case "IfStmt": {
      const test = emitExpr(s.test, isEffect);
      const cons = emitBlock(s.consequent, isEffect);
      const alt = s.alternate ? emitBlock(s.alternate, isEffect) : "";
      return s.alternate
        ? `if (${test}) {\n${indent(cons)}\n} else {\n${indent(alt)}\n}`
        : `if (${test}) {\n${indent(cons)}\n}`;
    }
    case "MatchStmt": {
      return emitMatchStmt(s, isEffect);
    }
    case "ExprStmt": {
      return `${emitExpr(s.expression, isEffect)};`;
    }
  }
}

// ---------- Expressions ----------

function emitExpr(e: Expr, isEffect: boolean): string {
  switch (e.kind) {
    case "IdentifierExpr":
      return e.id.name;
    case "LiteralExpr":
      return emitLiteral(e as LiteralExpr);
    case "ObjectExpr":
      return `{ ${e.fields.map((f) => `${f.key.name}: ${emitExpr(f.value, isEffect)}`).join(", ")} }`;
    case "ArrayExpr":
      return `[${e.elements.map((el) => emitExpr(el, isEffect)).join(", ")}]`;
    case "CallExpr":
      return emitCall(e, isEffect);
    case "MemberExpr":
      return `${emitExpr(e.object, isEffect)}.${e.property.name}`;
    case "UnaryExpr":
      return `${e.op}${paren(emitExpr(e.argument, isEffect))}`;
    case "BinaryExpr":
      return `${paren(emitExpr(e.left, isEffect))} ${e.op} ${paren(emitExpr(e.right, isEffect))}`;
    case "ResultOkExpr":
      return `{ type: "Ok", value: ${emitExpr(e.value, isEffect)} }`;
    case "ResultErrExpr":
      return `{ type: "Err", error: ${emitExpr(e.error, isEffect)} }`;
    case "OptionSomeExpr":
      return `{ kind: "some", value: ${emitExpr(e.value, isEffect)} }`;
    case "OptionNoneExpr":
      return `{ kind: "none" }`;
    case "BrandCastExpr":
      // v0.2: cast nominal “a ojo” — en v0.3 puedes validar la ref.
      return `${emitExpr(e.value, isEffect)} as any`;
    case "VariantExpr": {
      const payload =
        e.fields && e.fields.length
          ? `, ${e.fields.map((f) => `${f.key.name}: ${emitExpr(f.value, isEffect)}`).join(", ")} `
          : "";
      return `{ type: "${e.ctor.name}"${payload}}`;
    }
    case "MatchExpr":
      // Lo emitimos como IIFE + if encadenados para devolver valor.
      return emitMatchExpr(e, isEffect);
  }
}

function emitLiteral(e: LiteralExpr): string {
  switch (e.value.kind) {
    case "Bool":
      return e.value.value ? "true" : "false";
    case "Number":
      return String(e.value.value);
    case "String":
      return JSON.stringify(e.value.value);
  }
}

function emitCall(c: CallExpr, isEffect: boolean): string {
  // Caso más útil: llamada a capacidad → deps.<cap>.<method>(...)
  if (c.callee.kind === "MemberExpr") {
    const obj = c.callee.object;
    const prop = c.callee.property.name;
    // Si el objeto es un identificador que coincide con el nombre de la capability,
    // generamos deps.<cap>.<method>(args)
    if (obj.kind === "IdentifierExpr") {
      const cap = obj.id.name;
      const args = c.args.map((a) => emitExpr(a, isEffect)).join(", ");
      return `deps.${cap}.${prop}(${args})`;
    }
  }
  // Llamada normal
  const callee = emitExpr(c.callee, isEffect);
  const args = c.args.map((a) => emitExpr(a, isEffect)).join(", ");
  return `${callee}(${args})`;
}

// ---------- Match ----------

function emitMatchStmt(s: MatchStmt, isEffect: boolean): string {
  const subject = `_m_${fresh()}`;
  const head = `const ${subject} = ${emitExpr(s.expr, isEffect)};`;
  const chain = emitCasesAsIfs(subject, s.cases, isEffect, {
    returns: true,
    inlineReturn: true,
  });
  return `${head}\n${chain}`;
}

function emitMatchExpr(m: MatchExpr, isEffect: boolean): string {
  const subject = `_m_${fresh()}`;
  const ret = `_r_${fresh()}`;
  const head =
    `(() => { ` +
    `const ${subject} = ${emitExpr(m.expr, isEffect)}; ` +
    `let ${ret}: any;`;
  const chain = emitCasesAsIfs(subject, m.cases, isEffect, {
    returns: true,
    assignTo: ret,
  });
  return `${head}\n${indent(chain)}\nreturn ${ret};\n})()`;
}

type CaseEmitOpts =
  | { returns?: false }
  | { returns: true; assignTo?: string; inlineReturn?: boolean };

function emitCasesAsIfs(
  subject: string,
  cases: CaseClause[],
  isEffect: boolean,
  opts: CaseEmitOpts = { returns: false },
): string {
  const parts: string[] = [];
  cases.forEach((c, idx) => {
    const cond = patternCondition(subject, c.pattern);
    const bindings = emitBindings(subject, c.pattern).join("\n");
    let body: string;
    if ("kind" in c.body && (c.body as any).kind === "Block") {
      // statement-mode: bloque tal cual
      const block = emitBlock(c.body as Block, isEffect);
      if ((opts as any).returns && (opts as any).inlineReturn) {
        body = bindings
          ? `${bindings}\n${block}\nreturn;`
          : `${block}\nreturn;`;
      } else {
        body = bindings ? `${bindings}\n${block}` : block;
      }
    } else {
      // expresión del caso
      const expr = emitExpr(c.body as Expr, isEffect);
      if ((opts as any).returns) {
        if ((opts as any).inlineReturn) {
          const asg = `_r_${fresh()}`;
          body = bindings
            ? `${bindings}\nconst ${asg} = ${expr};\nreturn ${asg};`
            : `const ${asg} = ${expr};\nreturn ${asg};`;
        } else {
          const asg = (opts as any).assignTo as string;
          body = bindings
            ? `${bindings}\n${asg} = ${expr};`
            : `${asg} = ${expr};`;
        }
      } else {
        body = bindings ? `${bindings}\n${expr};` : `${expr};`;
      }
    }
    parts.push(
      `${idx === 0 ? "if" : "else if"} (${cond}) {\n${indent(body)}\n}`,
    );
  });
  // Nota: el checker asegura exhaustividad; aquí no añadimos else.
  return parts.join("\n");
}

/** Emit variable bindings for a pattern's fields and aliases. */
function emitBindings(subject: string, p: Pattern): string[] {
  const lines: string[] = [];
  if (
    p.kind === "VariantPattern" &&
    p.head.tag === "Named" &&
    p.fields?.length
  ) {
    for (const f of p.fields) {
      const name = f.alias?.name ?? f.name.name;
      lines.push(`const ${name} = ${subject}.${f.name.name};`);
    }
  }
  return lines;
}

function patternCondition(subject: string, p: Pattern): string {
  if (p.kind === "LiteralPattern") {
    return `${subject} === ${literalJS(p.value)}`;
  }
  // VariantPattern
  if (p.head.tag === "Literal") {
    return `${subject} === ${literalJS(p.head.value)}`;
  }
  // Named ctor
  return `${subject}.type === ${JSON.stringify(p.head.name.name)}`;
}

function literalJS(
  l:
    | LiteralPattern["value"]
    | { kind: "String" | "Number" | "Bool"; value: any },
) {
  switch (l.kind) {
    case "String":
      return JSON.stringify(l.value);
    case "Number":
      return String(l.value);
    case "Bool":
      return l.value ? "true" : "false";
  }
}

// ---------- Utils ----------

let _seq = 0;
function fresh() {
  return ++_seq;
}
function indent(s: string, n = 2) {
  const pad = " ".repeat(n);
  return s
    .split("\n")
    .map((l) => (l.length ? pad + l : l))
    .join("\n");
}
function paren(s: string): string {
  // Para ir sobre seguro en unarios/binarios, siempre parentizamos.
  return `(${s})`;
}

// Si quieres incrustar helpers en cada archivo generado, descomenta:
function runtimePrelude(): string {
  return `
 export type Brand<B extends string> = { readonly __brand: B };
 export type Result<T, E> = { type: "Ok"; value: T } | { type: "Err"; error: E };
 export type Option<T> = { kind: "some"; value: T } | { kind: "none" };
   `.trim();
}
