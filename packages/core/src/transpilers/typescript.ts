// packages/core/src/transpilers/typescript.ts
// Transpiler v0.5 — alineado con el EBNF y el AST actual:
// - Efectos: `uses a, b` -> deps tipado inline `{ a: A; b: B }`.
// - Reescritura de llamadas a capacidades solo si el objeto es una capability activa.
// - ObjectExpr con shorthand `{ foo }` soportado.
// - BrandCastExpr -> `as <Brand>`.
// - Match exhaustivo a if/else; Ok/Err/Some/None; contratos requires/ensures.

import * as AST from "../ast.js";
import { readFileSync } from "node:fs";
import { fileURLToPath } from "node:url";
import { dirname, resolve } from "node:path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const pkg = JSON.parse(
  readFileSync(resolve(__dirname, "../../package.json"), "utf8"),
) as { version: string };

// ---------- Emission Context ----------
type Ctx = {
  /** Capabilities conocidas a nivel de programa (sección `uses { ... }`). */
  programCaps: Map<string, string>;
  /** Capabilities activas en el ámbito actual (p.ej., dentro de un effect con `uses ...`). */
  activeCaps: Set<string>;
};

function makeProgramCaps(program: AST.Program): Map<string, string> {
  const map = new Map<string, string>();
  for (const u of program.uses?.entries ?? []) {
    // soporta tanto { name, typeName } como { name, target }
    const typeIdent = (u as any).typeName ?? (u as any).target;
    map.set(u.name.name, typeIdent?.name ?? "unknown");
  }
  return map;
}

// ---------- Public API ----------
export function emitTypeScript(program: AST.Program): string {
  const out: string[] = [];
  out.push(`// Generated by IntentLang v${pkg.version}`);
  out.push(`// DO NOT EDIT MANUALLY\n`);
  out.push(runtimePrelude());

  // Types
  if (program.types) {
    for (const t of program.types.declarations) {
      out.push(emitTypeDecl(t));
    }
    out.push("");
  }

  const baseCtx: Ctx = {
    programCaps: makeProgramCaps(program),
    activeCaps: new Set(),
  };

  // Funcs, Effects & Tests
  for (const item of program.items) {
    if (item.kind === "FuncDecl") out.push(emitFunc(item, baseCtx));
    else if (item.kind === "EffectDecl") out.push(emitEffect(item, baseCtx));
    else if (item.kind === "TestDecl") out.push(emitTest(item, baseCtx));
  }

  return out.join("\n");
}

// ---------- Types ----------
function emitTypeDecl(t: AST.TypeDecl): string {
  return `export type ${t.name.name} = ${tsType(t.expr)};`;
}

function tsType(t: AST.TypeExpr): string {
  switch (t.kind) {
    case "BasicType":
      return basicToTs(t);
    case "BrandType":
      // Brand sobre el tipo estructural base
      return `(${tsType((t as AST.BrandType).base)}) & Brand<${JSON.stringify((t as AST.BrandType).brand)}>`;
    case "LiteralType":
      return JSON.stringify((t as AST.LiteralType).value);
    case "RecordType":
      return recordToTs(t);
    case "GenericType":
      return genericToTs(t);
    case "UnionType":
      return unionToTs(t as any);
    case "FuncType":
      return funcTypeToTs(t as any);
    case "ArrayType":
      return `Array<${tsType((t as any).element)}>`;
    case "MapType":
      return `Map<${tsType((t as any).key)}, ${tsType((t as any).value)}>`;
    default: {
      // Soporte para extensiones manuales (p.ej. NamedType)
      const anyT = t as any;
      if (anyT?.kind === "NamedType" && anyT.name) {
        return anyT.name.name ?? String(anyT.name);
      }
      return "any /* TODO unknown type */";
    }
  }
}

function basicToTs(b: AST.BasicType): string {
  switch (b.name) {
    case "Unit":
      return "void";
    case "Bool":
      return "boolean";
    case "Int":
    case "Float":
      return "number";
    case "String":
      return "string";
    case "Bytes":
      return "Uint8Array";
    case "Uuid":
      return "string";
    case "DateTime":
      return "Date";
  }
}

function recordToTs(r: AST.RecordType): string {
  const fields = r.fields
    .map((f) => `  ${f.name.name}: ${tsType(f.type)};`)
    .join("\n");
  return `{\n${fields}\n}`;
}

function funcTypeToTs(f: {
  params?: Array<{ name?: AST.Identifier; type: AST.TypeExpr }>;
  returnType: AST.TypeExpr;
}): string {
  const ps = (f.params ?? [])
    .map((p, i) => `${p.name?.name ?? `p${i}`}: ${tsType(p.type)}`)
    .join(", ");
  return `(${ps}) => ${tsType(f.returnType)}`;
}

/** EBNF: UnionCtor = ident [ RecordType ] | LiteralType */
function unionToTs(u: { ctors: any[] }): string {
  const parts = u.ctors.map((c: any) => {
    if (c.kind === "LiteralCtor" || c.kind === "LiteralType") {
      const lit = c.literal?.value ?? c.value;
      return JSON.stringify(lit);
    }
    // Named ctor
    const name = c.name.name;
    if (c.fields && c.fields.fields?.length) {
      const extra = c.fields.fields
        .map((f: any) => `${f.name.name}: ${tsType(f.type)}`)
        .join("; ");
      return `{ type: ${JSON.stringify(name)}; ${extra} }`;
    }
    return `{ type: ${JSON.stringify(name)} }`;
  });
  return parts.join(" | ");
}

function genericToTs(g: AST.GenericType): string {
  const params = g.params.map((p) => tsType(p)).join(", ");
  return `${g.name.name}<${params}>`;
}

// ---------- Decls ----------
function emitFunc(fn: AST.FuncDecl, baseCtx: Ctx): string {
  const paramsTs = fn.params
    .map((p) => `${p.name.name}: ${tsType(p.type)}`)
    .join(", ");
  const retTs = tsType(fn.returnType);
  const ctx = { ...baseCtx, activeCaps: new Set<string>() }; // sin capabilities activas en funciones puras
  let body = emitBlock(fn.body, ctx, /*ensures*/ fn.contracts?.ensures);

  if (fn.contracts?.requires) {
    const req = emitExpr(fn.contracts.requires, ctx);
    body = `if (!(${req})) throw new Error('Precondition failed');\n${body}`;
  }
  return `export function ${fn.name.name}(${paramsTs}): ${retTs} {\n${indent(
    body,
  )}\n}\n`;
}

function effectDepsInlineType(eff: AST.EffectDecl, ctx: Ctx): string {
  // EBNF: ... "uses" ident { "," ident } ...
  const useIds: string[] = eff.uses?.map((id: AST.Identifier) => id.name) ?? [];
  const fields = useIds
    .map((n) => {
      const t = ctx.programCaps.get(n) ?? "unknown";
      return `  ${n}: ${t};`;
    })
    .join("\n");
  return `{\n${fields}\n}`;
}

function emitEffect(eff: AST.EffectDecl, baseCtx: Ctx): string {
  const depsType = effectDepsInlineType(eff, baseCtx);
  const paramsTs = [
    `deps: ${depsType}`,
    ...eff.params.map((p) => `${p.name.name}: ${tsType(p.type)}`),
  ].join(", ");
  const retTs = tsType(eff.returnType);

  // Contexto con capabilities activas
  const active = new Set<string>(
    eff.uses?.map((u: AST.Identifier) => u.name) ?? [],
  );
  const ctx: Ctx = { programCaps: baseCtx.programCaps, activeCaps: active };

  let body = emitBlock(eff.body, ctx, /*ensures*/ eff.contracts?.ensures);

  if (eff.contracts?.requires) {
    const req = emitExpr(eff.contracts.requires, ctx);
    body = `if (!(${req})) throw new Error('Precondition failed');\n${body}`;
  }
  return `export async function ${
    eff.name.name
  }(${paramsTs}): Promise<${retTs}> {\n${indent(body)}\n}\n`;
}

function emitTest(t: AST.TestDecl, baseCtx: Ctx): string {
  const ctx = { ...baseCtx, activeCaps: new Set<string>() };
  const body = emitBlock(t.body, ctx);
  return `export async function test_${t.name.name}(): Promise<void> {\n${indent(
    body,
  )}\n}\n`;
}

// ---------- Blocks & Statements ----------
function emitBlock(b: AST.Block, ctx: Ctx, ensures?: AST.Expr): string {
  return b.statements.map((s) => emitStmt(s, ctx, ensures)).join("\n");
}

function emitStmt(s: AST.Stmt, ctx: Ctx, ensures?: AST.Expr): string {
  switch (s.kind) {
    case "LetStmt": {
      const init = emitExpr(s.init, ctx);
      return `let ${s.id.name} = ${init};`;
    }
    case "ConstStmt": {
      const init = emitExpr(s.init, ctx);
      return `const ${s.id.name} = ${init};`;
    }
    case "AssignStmt": {
      const target = emitLValue(s.target, ctx);
      const value = emitExpr(s.value, ctx);
      return `${target} ${s.op} ${value};`;
    }
    case "UpdateStmt": {
      const target = emitLValue(s.target, ctx);
      return `${target}${s.op};`;
    }
    case "ReturnStmt": {
      if (!s.argument) {
        const chk = ensures
          ? `if (!(${emitExpr(ensures, ctx)})) throw new Error('Postcondition failed');\n`
          : "";
        return `${chk}return;`;
      }
      const e = emitExpr(s.argument, ctx);
      if (ensures) {
        const r = `_r_${fresh()}`;
        const chk = `if (!(${emitExpr(ensures, ctx)})) throw new Error('Postcondition failed');`;
        return `const ${r} = ${e};\n${chk}\nreturn ${r};`;
      }
      return `return ${e};`;
    }
    case "IfStmt": {
      const test = emitExpr(s.test, ctx);
      const cons = emitBlock(s.consequent, ctx, ensures);
      const alt = s.alternate ? emitBlock(s.alternate, ctx, ensures) : "";
      return s.alternate
        ? `if (${test}) {\n${indent(cons)}\n} else {\n${indent(alt)}\n}`
        : `if (${test}) {\n${indent(cons)}\n}`;
    }
    case "MatchStmt":
      return emitMatchStmt(s, ctx, ensures);
    case "ForStmt": {
      const iter = emitExpr(s.iterable, ctx);
      const body = emitBlock(s.body, ctx, ensures);
      return `for (const ${s.iterator.name} of ${iter}) {\n${indent(body)}\n}`;
    }
    case "WhileStmt": {
      const test = emitExpr(s.test, ctx);
      const body = emitBlock(s.body, ctx, ensures);
      return `while (${test}) {\n${indent(body)}\n}`;
    }
    case "TryStmt": {
      const tryB = emitBlock(s.tryBlock, ctx, ensures);
      const catchB = emitBlock(s.catchBlock, ctx, ensures);
      return `try {\n${indent(tryB)}\n} catch (${s.catchParam.name}) {\n${indent(
        catchB,
      )}\n}`;
    }
    case "BreakStmt":
      return `break;`;
    case "ContinueStmt":
      return `continue;`;
    case "ExprStmt":
      return `${emitExpr(s.expression, ctx)};`;
  }
  // Fallback (por si el AST añade nuevas variantes)
  return `/* unsupported stmt ${(s as any).kind} */`;
}

function emitLValue(lv: AST.LValue, ctx: Ctx): string {
  let s = lv.base.name;
  for (const step of lv.path) {
    if (step.kind === "LvProp") s += `.${step.name.name}`;
    else s += `[${emitExpr(step.index, ctx)}]`;
  }
  return s;
}

// ---------- Expressions ----------
function emitExpr(e: AST.Expr, ctx: Ctx): string {
  switch (e.kind) {
    case "IdentifierExpr":
      return e.id.name;
    case "LiteralExpr":
      return emitLiteral(e as AST.LiteralExpr);
    case "ObjectExpr":
      return emitObjectExpr(e as AST.ObjectExpr, ctx);
    case "ArrayExpr":
      return `[${(e as AST.ArrayExpr).elements
        .map((el) => emitExpr(el, ctx))
        .join(", ")}]`;
    case "MapExpr": {
      const m = e as AST.MapExpr;
      const pairs = m.entries
        .map((kv) => `[${emitExpr(kv.key, ctx)}, ${emitExpr(kv.value, ctx)}]`)
        .join(", ");
      return `new Map([${pairs}])`;
    }
    case "CallExpr":
      return emitCall(e as AST.CallExpr, ctx);
    case "MemberExpr":
      return `${emitExpr((e as AST.MemberExpr).object, ctx)}.${
        (e as AST.MemberExpr).property.name
      }`;
    case "IndexExpr":
      return `${emitExpr((e as AST.IndexExpr).object, ctx)}[${emitExpr(
        (e as AST.IndexExpr).index,
        ctx,
      )}]`;
    case "UnaryExpr":
      return `${(e as AST.UnaryExpr).op}${paren(
        emitExpr((e as AST.UnaryExpr).argument, ctx),
      )}`;
    case "PostfixUpdateExpr":
      return `${emitExpr((e as any).argument, ctx)}${(e as any).op}`;
    case "BinaryExpr":
      return `${paren(emitExpr((e as AST.BinaryExpr).left, ctx))} ${
        (e as AST.BinaryExpr).op
      } ${paren(emitExpr((e as AST.BinaryExpr).right, ctx))}`;
    case "ConditionalExpr":
      return `${emitExpr((e as AST.ConditionalExpr).test, ctx)} ? ${emitExpr(
        (e as AST.ConditionalExpr).consequent,
        ctx,
      )} : ${emitExpr((e as AST.ConditionalExpr).alternate, ctx)}`;
    case "ResultOkExpr":
      return `{ type: "Ok", value: ${emitExpr(
        (e as AST.ResultOkExpr).value,
        ctx,
      )} }`;
    case "ResultErrExpr":
      return `{ type: "Err", error: ${emitExpr(
        (e as AST.ResultErrExpr).error,
        ctx,
      )} }`;
    case "OptionSomeExpr":
      return `{ kind: "some", value: ${emitExpr(
        (e as AST.OptionSomeExpr).value,
        ctx,
      )} }`;
    case "OptionNoneExpr":
      return `{ kind: "none" }`;
    case "BrandCastExpr": {
      // EBNF: brand<Ident>(Expr) — target: Identifier
      const bc = e as AST.BrandCastExpr;
      return `${emitExpr(bc.value, ctx)} as ${bc.target.name}`;
    }
    case "VariantExpr": {
      const v = e as AST.VariantExpr;
      const payload =
        v.fields && v.fields.length
          ? `, ${v.fields
              .map((f) => `${f.key.name}: ${emitExpr(f.value, ctx)}`)
              .join(", ")} `
          : "";
      return `{ type: "${v.ctor.name}"${payload}}`;
    }
    case "MatchExpr":
      return emitMatchExpr(e as AST.MatchExpr, ctx);
  }
  return `/* unsupported expr ${(e as any).kind} */`;
}

function emitObjectExpr(o: AST.ObjectExpr, ctx: Ctx): string {
  // EBNF: RecordField = ident [ ":" , Expr ]
  // Soporta shorthand: `foo` -> `foo: foo`
  const parts = o.fields.map((f) => {
    if (f.value) return `${f.key.name}: ${emitExpr(f.value, ctx)}`;
    return `${f.key.name}: ${f.key.name}`;
  });
  return `{ ${parts.join(", ")} }`;
}

function emitLiteral(e: AST.LiteralExpr): string {
  switch (e.value.kind) {
    case "Bool":
      return e.value.value ? "true" : "false";
    case "Number":
      return String(e.value.value);
    case "String":
      return JSON.stringify(e.value.value);
  }
}

// Reescritura de capabilities solo si `obj` es ident y está en activeCaps.
function emitCall(c: AST.CallExpr, ctx: Ctx): string {
  if (c.callee.kind === "MemberExpr") {
    const m = c.callee as AST.MemberExpr;
    if (m.object.kind === "IdentifierExpr") {
      const cap = (m.object as AST.IdentifierExpr).id.name;
      if (ctx.activeCaps.has(cap)) {
        const prop = m.property.name;
        const args = c.args.map((a) => emitExpr(a, ctx)).join(", ");
        return `deps.${cap}.${prop}(${args})`;
      }
    }
  }
  const callee = emitExpr(c.callee, ctx);
  const args = c.args.map((a) => emitExpr(a, ctx)).join(", ");
  return `${callee}(${args})`;
}

// ---------- Match ----------
function emitMatchStmt(s: AST.MatchStmt, ctx: Ctx, ensures?: AST.Expr): string {
  const subject = `_m_${fresh()}`;
  const head = `const ${subject} = ${emitExpr(s.match.expr, ctx)};`;
  const chain = emitCasesAsIfs(
    subject,
    s.match.cases,
    ctx,
    { returns: true, inlineReturn: true },
    ensures,
  );
  return `${head}\n${chain}`;
}

function emitMatchExpr(m: AST.MatchExpr, ctx: Ctx): string {
  const subject = `_m_${fresh()}`;
  const ret = `_r_${fresh()}`;
  const head =
    `(() => { ` +
    `const ${subject} = ${emitExpr(m.expr, ctx)}; ` +
    `let ${ret}: any;`;
  const chain = emitCasesAsIfs(subject, m.cases, ctx, {
    returns: true,
    assignTo: ret,
  });
  return `${head}\n${indent(chain)}\nreturn ${ret};\n})()`;
}

type CaseEmitOpts =
  | { returns?: false }
  | { returns: true; assignTo?: string; inlineReturn?: boolean };

function emitCasesAsIfs(
  subject: string,
  cases: AST.CaseClause[],
  ctx: Ctx,
  opts: CaseEmitOpts = { returns: false },
  ensures?: AST.Expr,
): string {
  const parts: string[] = [];
  cases.forEach((c, idx) => {
    const baseCond = patternCondition(subject, c.pattern);
    let cond = baseCond;

    if (c.guard) {
      const guardBindings = emitBindings(subject, c.pattern).join("\n");
      const guardExpr = emitExpr(c.guard, ctx);
      const pre = guardBindings ? `${guardBindings}\n` : "";
      cond = `${baseCond} && (() => { ${pre}return ${guardExpr}; })()`;
    }

    const bindings = emitBindings(subject, c.pattern).join("\n");
    let body: string;

    if ((c.body as any).kind === "Block") {
      const block = emitBlock(c.body as AST.Block, ctx, ensures);
      if ((opts as any).returns && (opts as any).inlineReturn) {
        if (ensures) {
          const chk = `if (!(${emitExpr(
            ensures,
            ctx,
          )})) throw new Error('Postcondition failed');`;
          body = bindings
            ? `${bindings}\n${block}\n${chk}\nreturn;`
            : `${block}\n${chk}\nreturn;`;
        } else {
          body = bindings
            ? `${bindings}\n${block}\nreturn;`
            : `${block}\nreturn;`;
        }
      } else {
        body = bindings ? `${bindings}\n${block}` : block;
      }
    } else {
      const expr = emitExpr(c.body as AST.Expr, ctx);
      if ((opts as any).returns) {
        if ((opts as any).inlineReturn) {
          const asg = `_r_${fresh()}`;
          if (ensures) {
            const chk = `if (!(${emitExpr(
              ensures,
              ctx,
            )})) throw new Error('Postcondition failed');`;
            body = bindings
              ? `${bindings}\nconst ${asg} = ${expr};\n${chk}\nreturn ${asg};`
              : `const ${asg} = ${expr};\n${chk}\nreturn ${asg};`;
          } else {
            body = bindings
              ? `${bindings}\nconst ${asg} = ${expr};\nreturn ${asg};`
              : `const ${asg} = ${expr};\nreturn ${asg};`;
          }
        } else {
          const asg = (opts as any).assignTo as string;
          body = bindings
            ? `${bindings}\n${asg} = ${expr};`
            : `${asg} = ${expr};`;
        }
      } else {
        body = bindings ? `${bindings}\n${expr};` : `${expr};`;
      }
    }

    parts.push(
      `${idx === 0 ? "if" : "else if"} (${cond}) {\n${indent(body)}\n}`,
    );
  });
  return parts.join("\n");
}

/** Emit variable bindings for a pattern's fields and aliases. */
function emitBindings(subject: string, p: AST.Pattern): string[] {
  const lines: string[] = [];
  if (
    p.kind === "VariantPattern" &&
    p.head.tag === "Named" &&
    (p as any).fields?.length
  ) {
    for (const f of (p as any).fields as Array<{
      name: AST.Identifier;
      alias?: AST.Identifier;
    }>) {
      const name = f.alias?.name ?? f.name.name;
      lines.push(`const ${name} = ${subject}.${f.name.name};`);
    }
  }
  return lines;
}

function patternCondition(subject: string, p: AST.Pattern): string {
  if (p.kind === "LiteralPattern") {
    return `${subject} === ${literalJS(p.value)}`;
  }
  // VariantPattern
  if ((p as any).head?.tag === "Literal") {
    return `${subject} === ${literalJS((p as any).head.value)}`;
  }
  // Named ctor
  return `${subject}.type === ${JSON.stringify((p as any).head.name.name)}`;
}

function literalJS(
  l:
    | AST.LiteralPattern["value"]
    | { kind: "String" | "Number" | "Bool"; value: any },
) {
  switch (l.kind) {
    case "String":
      return JSON.stringify(l.value);
    case "Number":
      return String(l.value);
    case "Bool":
      return l.value ? "true" : "false";
  }
  return "undefined";
}

// ---------- Utils ----------
let _seq = 0;
function fresh() {
  return ++_seq;
}
function indent(s: string, n = 2) {
  const pad = " ".repeat(n);
  return s
    .split("\n")
    .map((l) => (l.length ? pad + l : l))
    .join("\n");
}
function paren(s: string): string {
  return `(${s})`;
}

// Helpers incrustados (Brand/Result/Option + fixed2Mul decl)
function runtimePrelude(): string {
  return `
export type Brand<B extends string> = { readonly __brand: B };
export type Result<T, E> = { type: "Ok"; value: T } | { type: "Err"; error: E };
export type Option<T> = { kind: "some"; value: T } | { kind: "none" };
export declare function fixed2Mul(
  a: number & Brand<"Fixed2">,
  b: number & Brand<"Fixed2">
): number & Brand<"Fixed2">;
  `.trim();
}
