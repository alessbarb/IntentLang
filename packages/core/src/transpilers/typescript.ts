import type {
  Program,
  TypeDecl,
  TypeExpr,
  Field,
  Variant,
} from "../ast.js";

function tsType(expr: TypeExpr): string {
  switch (expr.kind) {
    case "BasicType":
      return basic(expr.name);
    case "BrandType":
      return `${tsType(expr.base)} & Brand<"${expr.brand}">`;
    case "RecordType":
      return `{
${expr.fields.map(f => `  ${f.name}: ${tsType(f.type)};`).join("\n")}
}`;
    case "UnionType":
      return expr.variants
        .map(v => `{ type: "${v.name}"${v.fields.length ? `, ${v.fields.map(f => `${f.name}: ${tsType(f.type)}`).join(", ")} ` : ""}}`)
        .join(" | ");
    case "RefType":
      return expr.name;
  }
}

function basic(name: string): string {
  switch (name) {
    case "String":
      return "string";
    case "Int":
    case "Float":
      return "number";
    case "Bool":
      return "boolean";
    case "Uuid":
      return "string";
    case "DateTime":
      return "Date";
    default:
      return name;
  }
}

export function emitTypeScript(program: Program): string {
  const out: string[] = [];
  out.push("// Generated by ilc");
  if (program.types) {
    for (const decl of program.types.declarations) {
      out.push(`export type ${decl.name} = ${tsType(decl.expr)};`);
    }
  }
  if (program.uses) {
    out.push(
      `export interface Capabilities { ${program.uses.entries
        .map(u => `${u.name}: ${u.typeName}`)
        .join("; ")} }`
    );
  } else {
    out.push("export interface Capabilities {}");
  }
  for (const fn of program.funcs) {
    out.push(
      `export function ${fn.name}(${fn.args}): ${fn.returnType} {\n  ${fn.body}\n}`
    );
  }
  for (const eff of program.effects) {
    out.push(
      `export async function ${eff.name}(deps: Capabilities, ${eff.args}): Promise<${eff.result}> {\n  ${eff.body}\n}`
    );
  }
  return out.join("\n\n");
}
