// packages/core/src/transpilers/typescript.ts
// Transpiler v0.4 — alineado con el EBNF:
// - Efectos: `uses a, b` -> deps tipado inline `{ a: A; b: B }`.
// - Reescritura de llamadas a capacidades solo si el objeto es una capability activa.
// - ObjectExpr con shorthand `{ foo }` soportado.
// - BrandCastExpr -> `as <Brand>`.
// - Match exhaustivo a if/else; Ok/Err/Some/None; contratos requires/ensures.

import type {
  Program,
  TypeDecl,
  TypeExpr,
  RecordType,
  BrandType,
  BasicType,
  LiteralType,
  GenericType,
  FuncDecl,
  EffectDecl,
  TestDecl,
  TestBlock,
  Block,
  Identifier,
  Stmt,
  LetStmt,
  ReturnStmt,
  IfStmt,
  MatchStmt,
  ForStmt,
  ExprStmt,
  Expr,
  IdentifierExpr,
  LiteralExpr,
  ObjectExpr,
  ArrayExpr,
  CallExpr,
  MemberExpr,
  UnaryExpr,
  BinaryExpr,
  AssignExpr,
  ConditionalExpr,
  ResultOkExpr,
  ResultErrExpr,
  OptionSomeExpr,
  OptionNoneExpr,
  BrandCastExpr,
  VariantExpr,
  MatchExpr,
  CaseClause,
  Pattern,
  VariantPattern,
  LiteralPattern,
  Span,
} from "../ast.js";
import { readFileSync } from "node:fs";
import { fileURLToPath } from "node:url";
import { dirname, resolve } from "node:path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const pkg = JSON.parse(
  readFileSync(resolve(__dirname, "../../package.json"), "utf8"),
) as { version: string };

// ---------- Emission Context ----------
type Ctx = {
  /** Capabilities conocidas a nivel de programa (sección `uses { ... }`). */
  programCaps: Map<string, string>;
  /** Capabilities activas en el ámbito actual (p.ej., dentro de un effect con `uses ...`). */
  activeCaps: Set<string>;
};

function makeProgramCaps(program: Program): Map<string, string> {
  const map = new Map<string, string>();
  for (const u of program.uses?.entries ?? []) {
    map.set(u.name.name, u.typeName.name);
  }
  return map;
}

// ---------- Public API ----------
export function emitTypeScript(program: Program): string {
  const out: string[] = [];
  out.push(`// Generated by IntentLang v${pkg.version}`);
  out.push(`// DO NOT EDIT MANUALLY\n`);
  out.push(runtimePrelude());

  // Types
  if (program.types) {
    for (const t of program.types.declarations) {
      out.push(emitTypeDecl(t));
    }
    out.push("");
  }

  const baseCtx: Ctx = {
    programCaps: makeProgramCaps(program),
    activeCaps: new Set(),
  };

  // Funcs, Effects & Tests
  for (const item of program.items) {
    if (item.kind === "FuncDecl") out.push(emitFunc(item, baseCtx));
    else if (item.kind === "EffectDecl") out.push(emitEffect(item, baseCtx));
    else if (item.kind === "TestDecl") out.push(emitTest(item, baseCtx));
  }

  return out.join("\n");
}

// ---------- Types ----------
function emitTypeDecl(t: TypeDecl): string {
  return `export type ${t.name.name} = ${tsType(t.expr)};`;
}

function tsType(t: TypeExpr): string {
  switch (t.kind) {
    case "BasicType":
      return basicToTs(t);
    case "BrandType":
      // EBNF: BrandType = BasicType , "brand" , string ;
      return `(${basicToTs((t as BrandType).base)}) & Brand<${JSON.stringify((t as BrandType).brand)}>`;
    case "LiteralType":
      return JSON.stringify((t as LiteralType).value);
    case "RecordType":
      return recordToTs(t);
    case "GenericType":
      return genericToTs(t);
    case "UnionType":
      return unionToTs(t);
    case "NamedType":
      return (t as any).name.name; // según AST
    case "FuncType":
      // (a: T, b: U) -> R  — lo representamos como tipo función TS
      return funcTypeToTs(t as any);
    case "ArrayType":
    case "MapType":
      // En el AST suelen venir como GenericType "Array"/"Map". Si llegan tipados específicos:
      return (t as any).repr ?? "any";
  }
}

function basicToTs(b: BasicType): string {
  switch (b.name) {
    case "Unit":
      return "void";
    case "Bool":
      return "boolean";
    case "Int":
    case "Float":
      return "number";
    case "String":
      return "string";
    case "Bytes":
      return "Uint8Array";
    case "Uuid":
      return "string";
    case "DateTime":
      return "Date";
  }
}

function recordToTs(r: RecordType): string {
  const fields = r.fields
    .map((f) => `  ${f.name.name}: ${tsType(f.type)};`)
    .join("\n");
  return `{\n${fields}\n}`;
}

function funcTypeToTs(f: {
  params?: Array<{ name?: Identifier; type: TypeExpr }>;
  returnType: TypeExpr;
}): string {
  const ps = (f.params ?? [])
    .map((p, i) => `${p.name?.name ?? `p${i}`}: ${tsType(p.type)}`)
    .join(", ");
  return `(${ps}) => ${tsType(f.returnType)}`;
}

/** EBNF: UnionCtor = ident [ RecordType ] | LiteralType */
function unionToTs(u: TypeExpr & { kind: "UnionType" }): string {
  const parts = (u as any).ctors.map((c: any) => {
    if (c.kind === "LiteralType" || c.kind === "LiteralCtor") {
      const lit = c.literal?.value ?? c.value;
      return JSON.stringify(lit);
    }
    // Named ctor
    const name = c.name.name;
    if (c.fields && c.fields.fields?.length) {
      const extra = c.fields.fields
        .map((f: any) => `${f.name.name}: ${tsType(f.type)}`)
        .join("; ");
      return `{ type: ${JSON.stringify(name)}; ${extra} }`;
    }
    return `{ type: ${JSON.stringify(name)} }`;
  });
  return parts.join(" | ");
}

function genericToTs(g: GenericType): string {
  const params = g.params.map((p) => tsType(p)).join(", ");
  return `${g.name.name}<${params}>`;
}

// ---------- Decls ----------
function emitFunc(fn: FuncDecl, baseCtx: Ctx): string {
  const paramsTs = fn.params
    .map((p) => `${p.name.name}: ${tsType(p.type)}`)
    .join(", ");
  const retTs = tsType(fn.returnType);
  const ctx = { ...baseCtx, activeCaps: new Set<string>() }; // sin capabilities activas en funciones puras
  let body = emitBlock(fn.body, ctx, /*ensures*/ fn.contracts?.ensures);

  if (fn.contracts?.requires) {
    const req = emitExpr(fn.contracts.requires, ctx);
    body = `if (!(${req})) throw new Error('Precondition failed');\n${body}`;
  }
  return `export function ${fn.name.name}(${paramsTs}): ${retTs} {\n${indent(body)}\n}\n`;
}

function effectDepsInlineType(eff: EffectDecl, ctx: Ctx): string {
  // EBNF: ... "uses" ident { "," ident } ...
  const useIds: string[] = eff.uses?.map((id: Identifier) => id.name) ?? [];
  const fields = useIds
    .map((n) => {
      const t = ctx.programCaps.get(n) ?? "unknown";
      return `  ${n}: ${t};`;
    })
    .join("\n");
  return `{\n${fields}\n}`;
}

function emitEffect(eff: EffectDecl, baseCtx: Ctx): string {
  const depsType = effectDepsInlineType(eff, baseCtx);
  const paramsTs = [
    `deps: ${depsType}`,
    ...eff.params.map((p) => `${p.name.name}: ${tsType(p.type)}`),
  ].join(", ");
  const retTs = tsType(eff.returnType);

  // Contexto con capabilities activas
  const active = new Set<string>(
    eff.uses?.map((u: Identifier) => u.name) ?? [],
  );
  const ctx: Ctx = { programCaps: baseCtx.programCaps, activeCaps: active };

  let body = emitBlock(eff.body, ctx, /*ensures*/ eff.contracts?.ensures);

  if (eff.contracts?.requires) {
    const req = emitExpr(eff.contracts.requires, ctx);
    body = `if (!(${req})) throw new Error('Precondition failed');\n${body}`;
  }
  return `export async function ${eff.name.name}(${paramsTs}): Promise<${retTs}> {\n${indent(body)}\n}\n`;
}

function emitTest(t: TestDecl, baseCtx: Ctx): string {
  const ctx = { ...baseCtx, activeCaps: new Set<string>() };
  const body = emitBlock(t.body, ctx);
  return `export async function test_${t.name.name}(): Promise<void> {\n${indent(body)}\n}\n`;
}

// ---------- Blocks & Statements ----------
function emitBlock(b: Block | TestBlock, ctx: Ctx, ensures?: Expr): string {
  return b.statements.map((s) => emitStmt(s, ctx, ensures)).join("\n");
}

function emitStmt(s: Stmt, ctx: Ctx, ensures?: Expr): string {
  switch (s.kind) {
    case "LetStmt": {
      const init = emitExpr(s.init, ctx);
      return `let ${s.id.name} = ${init};`;
    }
    case "ConstStmt": {
      const init = emitExpr((s as any).init, ctx);
      return `const ${(s as any).id.name} = ${init};`;
    }
    case "ReturnStmt": {
      if (!s.argument) {
        const chk = ensures
          ? `if (!(${emitExpr(ensures, ctx)})) throw new Error('Postcondition failed');\n`
          : "";
        return `${chk}return;`;
      }
      const e = emitExpr(s.argument, ctx);
      if (ensures) {
        const r = `_r_${fresh()}`;
        const chk = `if (!(${emitExpr(ensures, ctx)})) throw new Error('Postcondition failed');`;
        return `const ${r} = ${e};\n${chk}\nreturn ${r};`;
      }
      return `return ${e};`;
    }
    case "IfStmt": {
      const test = emitExpr(s.test, ctx);
      const cons = emitBlock(s.consequent, ctx, ensures);
      const alt = s.alternate ? emitBlock(s.alternate, ctx, ensures) : "";
      return s.alternate
        ? `if (${test}) {\n${indent(cons)}\n} else {\n${indent(alt)}\n}`
        : `if (${test}) {\n${indent(cons)}\n}`;
    }
    case "MatchStmt":
      return emitMatchStmt(s, ctx, ensures);
    case "ForStmt": {
      const iter = emitExpr(s.iterable, ctx);
      const body = emitBlock(s.body, ctx, ensures);
      return `for (const ${s.iterator.name} of ${iter}) {\n${indent(body)}\n}`;
    }
    case "ExprStmt":
      return `${emitExpr(s.expression, ctx)};`;
  }
  // Fallback (por si el AST añade nuevas variantes)
  return `/* unsupported stmt ${JSON.stringify((s as any).kind)} */`;
}

// ---------- Expressions ----------
function emitExpr(e: Expr, ctx: Ctx): string {
  switch (e.kind) {
    case "IdentifierExpr":
      return e.id.name;
    case "LiteralExpr":
      return emitLiteral(e as LiteralExpr);
    case "ObjectExpr":
      return emitObjectExpr(e as ObjectExpr, ctx);
    case "ArrayExpr":
      return `[${(e as ArrayExpr).elements.map((el) => emitExpr(el, ctx)).join(", ")}]`;
    case "CallExpr":
      return emitCall(e as CallExpr, ctx);
    case "MemberExpr":
      return `${emitExpr((e as MemberExpr).object, ctx)}.${(e as MemberExpr).property.name}`;
    case "UnaryExpr":
      return `${(e as UnaryExpr).op}${paren(emitExpr((e as UnaryExpr).argument, ctx))}`;
    case "BinaryExpr":
      return `${paren(emitExpr((e as BinaryExpr).left, ctx))} ${(e as BinaryExpr).op} ${paren(emitExpr((e as BinaryExpr).right, ctx))}`;
    case "AssignExpr":
      return `${emitExpr((e as AssignExpr).left, ctx)} ${(e as AssignExpr).op} ${emitExpr((e as AssignExpr).right, ctx)}`;
    case "ConditionalExpr":
      return `${emitExpr((e as ConditionalExpr).test, ctx)} ? ${emitExpr((e as ConditionalExpr).consequent, ctx)} : ${emitExpr((e as ConditionalExpr).alternate, ctx)}`;
    case "ResultOkExpr":
      return `{ type: "Ok", value: ${emitExpr((e as ResultOkExpr).value, ctx)} }`;
    case "ResultErrExpr":
      return `{ type: "Err", error: ${emitExpr((e as ResultErrExpr).error, ctx)} }`;
    case "OptionSomeExpr":
      return `{ kind: "some", value: ${emitExpr((e as OptionSomeExpr).value, ctx)} }`;
    case "OptionNoneExpr":
      return `{ kind: "none" }`;
    case "BrandCastExpr": {
      // EBNF: brand<Ident>(Expr) — target: Identifier
      const bc = e as BrandCastExpr;
      const brandName = bc.target.name;
      return `${emitExpr(bc.value, ctx)} as ${brandName}`;
    }
    case "VariantExpr": {
      const v = e as VariantExpr;
      const payload =
        v.fields && v.fields.length
          ? `, ${v.fields.map((f) => `${f.key.name}: ${emitExpr(f.value, ctx)}`).join(", ")} `
          : "";
      return `{ type: "${v.ctor.name}"${payload}}`;
    }
    case "MatchExpr":
      return emitMatchExpr(e as MatchExpr, ctx);
  }
  return `/* unsupported expr ${JSON.stringify((e as any).kind)} */`;
}

function emitObjectExpr(o: ObjectExpr, ctx: Ctx): string {
  // EBNF: RecordField = ident [ ":" , Expr ]
  // Soporta shorthand: `foo` -> `foo: foo`
  const parts = o.fields.map((f) => {
    if (f.value) return `${f.key.name}: ${emitExpr(f.value, ctx)}`;
    return `${f.key.name}: ${f.key.name}`;
  });
  return `{ ${parts.join(", ")} }`;
}

function emitLiteral(e: LiteralExpr): string {
  switch (e.value.kind) {
    case "Bool":
      return e.value.value ? "true" : "false";
    case "Number":
      return String(e.value.value);
    case "String":
      return JSON.stringify(e.value.value);
  }
}

function emitCall(c: CallExpr, ctx: Ctx): string {
  // Reescritura de capabilities solo si `obj` es un ident y está en activeCaps.
  if (c.callee.kind === "MemberExpr") {
    const m = c.callee as MemberExpr;
    if (m.object.kind === "IdentifierExpr") {
      const cap = (m.object as IdentifierExpr).id.name;
      if (ctx.activeCaps.has(cap)) {
        const prop = m.property.name;
        const args = c.args.map((a) => emitExpr(a, ctx)).join(", ");
        return `deps.${cap}.${prop}(${args})`;
      }
    }
  }
  const callee = emitExpr(c.callee, ctx);
  const args = c.args.map((a) => emitExpr(a, ctx)).join(", ");
  return `${callee}(${args})`;
}

// ---------- Match ----------
function emitMatchStmt(s: MatchStmt, ctx: Ctx, ensures?: Expr): string {
  const subject = `_m_${fresh()}`;
  const head = `const ${subject} = ${emitExpr(s.expr, ctx)};`;
  const chain = emitCasesAsIfs(
    subject,
    s.cases,
    ctx,
    { returns: true, inlineReturn: true },
    ensures,
  );
  return `${head}\n${chain}`;
}

function emitMatchExpr(m: MatchExpr, ctx: Ctx): string {
  const subject = `_m_${fresh()}`;
  const ret = `_r_${fresh()}`;
  const head =
    `(() => { ` +
    `const ${subject} = ${emitExpr(m.expr, ctx)}; ` +
    `let ${ret}: any;`;
  const chain = emitCasesAsIfs(subject, m.cases, ctx, {
    returns: true,
    assignTo: ret,
  });
  return `${head}\n${indent(chain)}\nreturn ${ret};\n})()`;
}

type CaseEmitOpts =
  | { returns?: false }
  | { returns: true; assignTo?: string; inlineReturn?: boolean };

function emitCasesAsIfs(
  subject: string,
  cases: CaseClause[],
  ctx: Ctx,
  opts: CaseEmitOpts = { returns: false },
  ensures?: Expr,
): string {
  const parts: string[] = [];
  cases.forEach((c, idx) => {
    const baseCond = patternCondition(subject, c.pattern);
    let cond = baseCond;

    if (c.guard) {
      const guardBindings = emitBindings(subject, c.pattern).join("\n");
      const guardExpr = emitExpr(c.guard, ctx);
      const pre = guardBindings ? `${guardBindings}\n` : "";
      cond = `${baseCond} && (() => { ${pre}return ${guardExpr}; })()`;
    }

    const bindings = emitBindings(subject, c.pattern).join("\n");
    let body: string;

    if ("kind" in c.body && (c.body as any).kind === "Block") {
      const block = emitBlock(c.body as Block, ctx, ensures);
      if ((opts as any).returns && (opts as any).inlineReturn) {
        if (ensures) {
          const chk = `if (!(${emitExpr(ensures, ctx)})) throw new Error('Postcondition failed');`;
          body = bindings
            ? `${bindings}\n${block}\n${chk}\nreturn;`
            : `${block}\n${chk}\nreturn;`;
        } else {
          body = bindings
            ? `${bindings}\n${block}\nreturn;`
            : `${block}\nreturn;`;
        }
      } else {
        body = bindings ? `${bindings}\n${block}` : block;
      }
    } else {
      const expr = emitExpr(c.body as Expr, ctx);
      if ((opts as any).returns) {
        if ((opts as any).inlineReturn) {
          const asg = `_r_${fresh()}`;
          if (ensures) {
            const chk = `if (!(${emitExpr(ensures, ctx)})) throw new Error('Postcondition failed');`;
            body = bindings
              ? `${bindings}\nconst ${asg} = ${expr};\n${chk}\nreturn ${asg};`
              : `const ${asg} = ${expr};\n${chk}\nreturn ${asg};`;
          } else {
            body = bindings
              ? `${bindings}\nconst ${asg} = ${expr};\nreturn ${asg};`
              : `const ${asg} = ${expr};\nreturn ${asg};`;
          }
        } else {
          const asg = (opts as any).assignTo as string;
          body = bindings
            ? `${bindings}\n${asg} = ${expr};`
            : `${asg} = ${expr};`;
        }
      } else {
        body = bindings ? `${bindings}\n${expr};` : `${expr};`;
      }
    }

    parts.push(
      `${idx === 0 ? "if" : "else if"} (${cond}) {\n${indent(body)}\n}`,
    );
  });
  return parts.join("\n");
}

/** Emit variable bindings for a pattern's fields and aliases. */
function emitBindings(subject: string, p: Pattern): string[] {
  const lines: string[] = [];
  if (
    p.kind === "VariantPattern" &&
    p.head.tag === "Named" &&
    p.fields?.length
  ) {
    for (const f of p.fields) {
      const name = f.alias?.name ?? f.name.name;
      lines.push(`const ${name} = ${subject}.${f.name.name};`);
    }
  }
  return lines;
}

function patternCondition(subject: string, p: Pattern): string {
  if (p.kind === "LiteralPattern") {
    return `${subject} === ${literalJS(p.value)}`;
  }
  // VariantPattern
  if ((p as any).head.tag === "Literal") {
    return `${subject} === ${literalJS((p as any).head.value)}`;
  }
  // Named ctor
  return `${subject}.type === ${JSON.stringify((p as any).head.name.name)}`;
}

function literalJS(
  l:
    | LiteralPattern["value"]
    | { kind: "String" | "Number" | "Bool"; value: any },
) {
  switch (l.kind) {
    case "String":
      return JSON.stringify(l.value);
    case "Number":
      return String(l.value);
    case "Bool":
      return l.value ? "true" : "false";
  }
  return "undefined";
}

// ---------- Utils ----------
let _seq = 0;
function fresh() {
  return ++_seq;
}
function indent(s: string, n = 2) {
  const pad = " ".repeat(n);
  return s
    .split("\n")
    .map((l) => (l.length ? pad + l : l))
    .join("\n");
}
function paren(s: string): string {
  return `(${s})`;
}

// Helpers incrustados (Brand/Result/Option + fixed2Mul decl)
function runtimePrelude(): string {
  return `
export type Brand<B extends string> = { readonly __brand: B };
export type Result<T, E> = { type: "Ok"; value: T } | { type: "Err"; error: E };
export type Option<T> = { kind: "some"; value: T } | { kind: "none" };
export declare function fixed2Mul(
  a: number & Brand<"Fixed2">,
  b: number & Brand<"Fixed2">
): number & Brand<"Fixed2">;
  `.trim();
}
