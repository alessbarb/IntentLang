{"source_il":"uses { random: Random { } }\n\nfunc add(a: Int, b: Int): Int\n  requires a >= 0 && b >= 0\n  ensures _ >= a && _ >= b\n{ return a + b; }\n\neffect rollDie(): Int uses random {\n  return ((random.next() * 6) >> 0) + 1;\n}\n\ntest deterministic {\n  let sum = add(1, 2);\n  let first = rollDie();\n  let second = rollDie();\n}\n\n","transpiled_py":"# Generated by IntentLang\n# DO NOT EDIT MANUALLY\n\nfrom __main__ import Random, Result\n\n# TODO: Implementar un sistema de ordenación de tipos basado en dependencias en lugar de este enfoque simple de dos pasadas.\n\ndef add(a: int, b: int) -> int:\n    assert a >= 0 and b >= 0, \"Precondition failed\"\n    # TODO: Implementar la cláusula 'ensures'. Podría requerir decorar la función o inyectar aserciones antes de cada 'return'.\n    return a + b\n\ndef rollDie() -> int:\n    # TODO: Implementar la cláusula 'ensures' para efectos.\n    # Stmt type 'ExprStmt' not implemented\n\ndef test_deterministic():\n    # TODO: Añadir el setup del runtime (initRuntime) y el paso de dependencias a los tests que usan efectos.\n    sum = add(1, 2)\n    first = rollDie()\n    second = rollDie()","ast":null}
{"source_il":"types {\n  type Fixed2 = Int brand \"Fixed2\";\n}\n\nfunc mul(a: Fixed2, b: Fixed2): Fixed2\n{\n  return fixed2Mul(a, b);\n}\n","transpiled_py":"# Generated by IntentLang\n# DO NOT EDIT MANUALLY\n\nfrom __main__ import Result\n\n# TODO: Implementar un sistema de ordenación de tipos basado en dependencias en lugar de este enfoque simple de dos pasadas.\nFixed2 = NewType('Fixed2', int)\n\ndef mul(a: Fixed2, b: Fixed2) -> Fixed2:\n    # TODO: Implementar la cláusula 'ensures'. Podría requerir decorar la función o inyectar aserciones antes de cada 'return'.\n    return fixed2Mul(a, b)","ast":null}
{"source_il":"intent \"Invoice service\"\n\r\nuses {\r\n  http: Http { baseUrl: \"https://api.example.com\", timeoutMs: 3000 },\r\n  clock: Clock {},\r\n}\r\n\r\ntypes {\r\n  type InvoiceId = Uuid;\r\n  type Invoice = {\r\n    id: InvoiceId,\r\n    orderId: Uuid,\r\n    issuedAt: DateTime,\r\n  };\r\n  type InvoiceError = { code: Int, message: String };\r\n}\r\n\r\neffect generateInvoice(orderId: Uuid): Result<Invoice, InvoiceError> uses http, clock {\n  return http.post(\"/invoices\", { orderId, issuedAt: clock.now() });\n}\n","transpiled_py":"# Generated by IntentLang\n# DO NOT EDIT MANUALLY\n\nfrom __main__ import Http, Clock, Result\n\n# TODO: Implementar un sistema de ordenación de tipos basado en dependencias en lugar de este enfoque simple de dos pasadas.\n@dataclass\nclass Invoice:\n    id: InvoiceId\n    orderId: str\n    issuedAt: datetime\n\n@dataclass\nclass InvoiceError:\n    code: int\n    message: str\n\nInvoiceId = str\n\nasync def generateInvoice(deps, orderId: str) -> Result[Invoice, InvoiceError]:\n    # TODO: Implementar la cláusula 'ensures' para efectos.\n    # Stmt type 'ExprStmt' not implemented","ast":null}
{"source_il":"intent \"Notification service\" tags [\"notifications\"]\r\n\r\nuses {\r\n  http: Http { baseUrl: \"https://api.example.com\", timeoutMs: 3000 },\r\n}\r\n\r\ntypes {\r\n  type NotificationId = Uuid;\r\n  type Notification = {\r\n    id: NotificationId,\r\n    userId: Uuid,\r\n    message: String,\r\n  };\r\n  type NotificationError = { code: Int, message: String };\r\n}\r\n\r\neffect sendNotification(input: { userId: Uuid, message: String }): Result<Notification, NotificationError> uses http {\n  return http.post(\"/notifications\", input);\n}\n","transpiled_py":"# Generated by IntentLang\n# DO NOT EDIT MANUALLY\n\nfrom __main__ import Http, Result\n\n# TODO: Implementar un sistema de ordenación de tipos basado en dependencias en lugar de este enfoque simple de dos pasadas.\n@dataclass\nclass Notification:\n    id: NotificationId\n    userId: str\n    message: str\n\n@dataclass\nclass NotificationError:\n    code: int\n    message: str\n\nNotificationId = str\n\nasync def sendNotification(deps, input: object) -> Result[Notification, NotificationError]:\n    # TODO: Implementar la cláusula 'ensures' para efectos.\n    # Stmt type 'ExprStmt' not implemented","ast":null}
{"source_il":"intent \"Order service\" tags [\"api\",\"orders\"]\r\n\r\nuses {\r\n  http: Http { baseUrl: \"https://api.example.com\", timeoutMs: 3000 },\r\n  random: Random { seed: 42 },\r\n}\r\n\r\ntypes {\r\n  type OrderId = Uuid;\r\n  type Order = {\r\n    id: OrderId,\r\n    userId: Uuid,\r\n    total: Float where _ >= 0,\r\n  };\r\n  type OrderError = { code: Int, message: String };\r\n}\r\n\r\neffect createOrder(input: { userId: Uuid, total: Float }): Result<Order, OrderError> uses http, random {\r\n  let id = random.next().toString();\r\n  return http.post(\"/orders\", { id: brand<OrderId>(id), userId: input.userId, total: input.total });\r\n}\r\n","transpiled_py":"# Generated by IntentLang\n# DO NOT EDIT MANUALLY\n\nfrom __main__ import Http, Random, Result\n\n# TODO: Implementar un sistema de ordenación de tipos basado en dependencias en lugar de este enfoque simple de dos pasadas.\n@dataclass\nclass Order:\n    id: OrderId\n    userId: str\n    total: float\n\n@dataclass\nclass OrderError:\n    code: int\n    message: str\n\nOrderId = str\n\nasync def createOrder(deps, input: object) -> Result[Order, OrderError]:\n    # TODO: Implementar la cláusula 'ensures' para efectos.\n    # Stmt type 'ExprStmt' not implemented","ast":null}
{"source_il":"intent \"Payment service\" tags [\"payments\"]\r\n\r\nuses {\r\n  http: Http { baseUrl: \"https://api.example.com\", timeoutMs: 3000 },\r\n}\r\n\r\ntypes {\r\n  type CardNumber = String brand \"CardNumber\" where matches(\"^\\\\d{16}$\");\r\n  type PaymentId = Uuid;\r\n  type Payment =\r\n    | Card { id: PaymentId, card: CardNumber }\r\n    | Cash { id: PaymentId, amount: Float where _ >= 0 };\r\n  type PaymentError = { code: Int, message: String };\r\n}\r\n\r\neffect processPayment(p: Payment): Result<Bool, PaymentError> uses http {\n  return http.post(\"/payments\", p);\n}\n","transpiled_py":"# Generated by IntentLang\n# DO NOT EDIT MANUALLY\n\nfrom __main__ import Http, Result\n\n# TODO: Implementar un sistema de ordenación de tipos basado en dependencias en lugar de este enfoque simple de dos pasadas.\n@dataclass\nclass Card:\n    id: PaymentId\n    card: CardNumber\n\n@dataclass\nclass Cash:\n    id: PaymentId\n    amount: float\n\n@dataclass\nclass PaymentError:\n    code: int\n    message: str\n\nCardNumber = NewType('CardNumber', str)\nPaymentId = str\nPayment = Union[Card, Cash]\n\nasync def processPayment(deps, p: Payment) -> Result[bool, PaymentError]:\n    # TODO: Implementar la cláusula 'ensures' para efectos.\n    # Stmt type 'ExprStmt' not implemented","ast":null}
{"source_il":"intent \"User service\" tags [\"api\",\"users\"]\r\n\r\nuses {\r\n  http: Http { baseUrl: \"https://api.example.com\", timeoutMs: 2500 },\r\n  clock: Clock {},\r\n}\r\n\r\ntypes {\r\n  type Email = String brand \"Email\" where matches(\"^[^@]+@[^@]+\\\\.[^@]+$\");\r\n  type UserId = Uuid;\r\n  type User = {\r\n    id: UserId,\r\n    name: String where _.length >= 2,\r\n    email: Email,\r\n    createdAt: DateTime,\r\n  };\r\n  type ApiError = { code: Int, message: String };\r\n}\r\n\r\nfunc toEmail(s: String): Result<Email, String> {\r\n  if matches(\"^[^@]+@[^@]+\\\\.[^@]+$\", s) {\r\n    return Ok(brand<Email>(s));\r\n  } else {\r\n    return Err(\"Invalid email\");\r\n  }\r\n}\r\n\r\neffect createUser(input: { name: String, email: Email }): Result<User, ApiError> uses http, clock {\r\n  return http.post(\"/users\", {\r\n    name: input.name,\r\n    email: input.email,\r\n    createdAt: clock.now(),\r\n  });\r\n}\r\n","transpiled_py":"# Generated by IntentLang\n# DO NOT EDIT MANUALLY\n\nfrom __main__ import Http, Clock, Result\n\n# TODO: Implementar un sistema de ordenación de tipos basado en dependencias en lugar de este enfoque simple de dos pasadas.\n@dataclass\nclass User:\n    id: UserId\n    name: str\n    email: Email\n    createdAt: datetime\n\n@dataclass\nclass ApiError:\n    code: int\n    message: str\n\nEmail = NewType('Email', str)\nUserId = str\n\ndef toEmail(s: str) -> Result[Email, str]:\n    # TODO: Implementar la cláusula 'ensures'. Podría requerir decorar la función o inyectar aserciones antes de cada 'return'.\n    # Stmt type 'ExprStmt' not implemented\n\nasync def createUser(deps, input: object) -> Result[User, ApiError]:\n    assert len(input.name) >= 2, \"Precondition failed\"\n    # TODO: Implementar la cláusula 'ensures' para efectos.\n    # Stmt type 'ExprStmt' not implemented","ast":null}
