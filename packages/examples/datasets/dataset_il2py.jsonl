{"source_il":"uses { random: Random { } }\n\nfunc add(a: Int, b: Int): Int\n  requires a >= 0 && b >= 0\n  ensures _ >= a && _ >= b\n{ return a + b; }\n\neffect rollDie(): Int uses random {\n  return ((random.next() * 6) >> 0) + 1;\n}\n\ntest deterministic {\n  let sum = add(1, 2);\n  let first = rollDie();\n  let second = rollDie();\n}\n\n","transpiled_py":"from __future__ import annotations\n# Generated by IntentLang\n# DO NOT EDIT MANUALLY\n\nfrom ._prelude import Random, Result  # Random not used in this stub, kept for parity\n\ndef add(a: int, b: int) -> int:\n    assert a >= 0 and b >= 0, \"Precondition failed\"\n    return a + b\n\ndef rollDie() -> int:\n    # Deterministic stub for goldens\n    return 4\n\ndef test_deterministic():\n    total = add(1, 2)\n    first = rollDie()\n    second = rollDie()\n    # no asserts on purpose – snapshot golden\n    _ = (total, first, second)\n","ast":null}
{"source_il":"types {\n  type Fixed2 = Int brand \"Fixed2\";\n}\n\nfunc mul(a: Fixed2, b: Fixed2): Fixed2\n{\n  return fixed2Mul(a, b);\n}\n","transpiled_py":"from __future__ import annotations\n# Generated by IntentLang\n# DO NOT EDIT MANUALLY\n\nfrom typing import NewType, cast\nfrom ._prelude import Result\n\nFixed2 = NewType(\"Fixed2\", int)\n\ndef fixed2_mul(a: Fixed2, b: Fixed2) -> Fixed2:\n    # Mirrors TS fixed2Mul: (a*b)/100 with integer cents\n    raw = int(cast(int, a)) * int(cast(int, b))\n    return cast(Fixed2, raw // 100)\n\ndef mul(a: Fixed2, b: Fixed2) -> Fixed2:\n    return fixed2_mul(a, b)\n","ast":null}
{"source_il":"intent \"Invoice service\"\n\r\nuses {\r\n  http: Http { baseUrl: \"https://api.example.com\", timeoutMs: 3000 },\r\n  clock: Clock {},\r\n}\r\n\r\ntypes {\r\n  type InvoiceId = Uuid;\r\n  type Invoice = {\r\n    id: InvoiceId,\r\n    orderId: Uuid,\r\n    issuedAt: DateTime,\r\n  };\r\n  type InvoiceError = { code: Int, message: String };\r\n}\r\n\r\neffect generateInvoice(orderId: Uuid): Result<Invoice, InvoiceError> uses http, clock {\n  return http.post(\"/invoices\", { orderId, issuedAt: clock.now() });\n}\n","transpiled_py":"from __future__ import annotations\n# Generated by IntentLang\n# DO NOT EDIT MANUALLY\n\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Union\nfrom ._prelude import Http, Clock, Result, Err\n\nInvoiceId = str\n\n@dataclass\nclass Invoice:\n    id: InvoiceId\n    orderId: str\n    issuedAt: datetime\n\n@dataclass\nclass InvoiceError:\n    code: int\n    message: str\n\nasync def generateInvoice(\n    deps,  # e.g. deps: {\"http\": Http, \"clock\": Clock}\n    orderId: str,\n) -> Result[Invoice, InvoiceError]:\n    # Deterministic stub – mirrors TS golden shape\n    return Err(InvoiceError(code=501, message=\"Not implemented\"))\n","ast":null}
{"source_il":"intent \"Notification service\" tags [\"notifications\"]\r\n\r\nuses {\r\n  http: Http { baseUrl: \"https://api.example.com\", timeoutMs: 3000 },\r\n}\r\n\r\ntypes {\r\n  type NotificationId = Uuid;\r\n  type Notification = {\r\n    id: NotificationId,\r\n    userId: Uuid,\r\n    message: String,\r\n  };\r\n  type NotificationError = { code: Int, message: String };\r\n}\r\n\r\neffect sendNotification(input: { userId: Uuid, message: String }): Result<Notification, NotificationError> uses http {\n  return http.post(\"/notifications\", input);\n}\n","transpiled_py":"from __future__ import annotations\n# Generated by IntentLang\n# DO NOT EDIT MANUALLY\n\nfrom dataclasses import dataclass\nfrom ._prelude import Http, Result, Err\n\nNotificationId = str\n\n@dataclass\nclass Notification:\n    id: NotificationId\n    userId: str\n    message: str\n\n@dataclass\nclass NotificationError:\n    code: int\n    message: str\n\nasync def sendNotification(\n    deps,  # e.g. {\"http\": Http}\n    input: object,\n) -> Result[Notification, NotificationError]:\n    return Err(NotificationError(code=501, message=\"Not implemented\"))\n","ast":null}
{"source_il":"intent \"Order service\" tags [\"api\",\"orders\"]\r\n\r\nuses {\r\n  http: Http { baseUrl: \"https://api.example.com\", timeoutMs: 3000 },\r\n  random: Random { seed: 42 },\r\n}\r\n\r\ntypes {\r\n  type OrderId = Uuid;\r\n  type Order = {\r\n    id: OrderId,\r\n    userId: Uuid,\r\n    total: Float where _ >= 0,\r\n  };\r\n  type OrderError = { code: Int, message: String };\r\n}\r\n\r\neffect createOrder(input: { userId: Uuid, total: Float }): Result<Order, OrderError> uses http, random {\r\n  let id = random.next().toString();\r\n  return http.post(\"/orders\", { id: brand<OrderId>(id), userId: input.userId, total: input.total });\r\n}\r\n","transpiled_py":"from __future__ import annotations\n# Generated by IntentLang\n# DO NOT EDIT MANUALLY\n\nfrom dataclasses import dataclass\nfrom ._prelude import Http, Random, Result, Err\n\nOrderId = str\n\n@dataclass\nclass Order:\n    id: OrderId\n    userId: str\n    total: float\n\n@dataclass\nclass OrderError:\n    code: int\n    message: str\n\nasync def createOrder(\n    deps,  # e.g. {\"http\": Http, \"random\": Random}\n    input: object,  # e.g. {\"userId\": str, \"total\": float}\n) -> Result[Order, OrderError]:\n    return Err(OrderError(code=501, message=\"Not implemented\"))\n","ast":null}
{"source_il":"intent \"Payment service\" tags [\"payments\"]\r\n\r\nuses {\r\n  http: Http { baseUrl: \"https://api.example.com\", timeoutMs: 3000 },\r\n}\r\n\r\ntypes {\r\n  type CardNumber = String brand \"CardNumber\" where matches(\"^\\\\d{16}$\");\r\n  type PaymentId = Uuid;\r\n  type Payment =\r\n    | Card { id: PaymentId, card: CardNumber }\r\n    | Cash { id: PaymentId, amount: Float where _ >= 0 };\r\n  type PaymentError = { code: Int, message: String };\r\n}\r\n\r\neffect processPayment(p: Payment): Result<Bool, PaymentError> uses http {\n  return http.post(\"/payments\", p);\n}\n","transpiled_py":"from __future__ import annotations\n# Generated by IntentLang\n# DO NOT EDIT MANUALLY\n\nfrom dataclasses import dataclass\nfrom typing import NewType, Union\nfrom ._prelude import Http, Result, Err\n\nCardNumber = NewType(\"CardNumber\", str)\nPaymentId = str\n\n@dataclass\nclass Card:\n    id: PaymentId\n    card: CardNumber\n\n@dataclass\nclass Cash:\n    id: PaymentId\n    amount: float\n\nPayment = Union[Card, Cash]\n\n@dataclass\nclass PaymentError:\n    code: int\n    message: str\n\nasync def processPayment(\n    deps,  # e.g. {\"http\": Http}\n    p: Payment,\n) -> Result[bool, PaymentError]:\n    return Err(PaymentError(code=501, message=\"Not implemented\"))\n","ast":null}
{"source_il":"intent \"User service\" tags [\"api\",\"users\"]\r\n\r\nuses {\r\n  http: Http { baseUrl: \"https://api.example.com\", timeoutMs: 2500 },\r\n  clock: Clock {},\r\n}\r\n\r\ntypes {\r\n  type Email = String brand \"Email\" where matches(\"^[^@]+@[^@]+\\\\.[^@]+$\");\r\n  type UserId = Uuid;\r\n  type User = {\r\n    id: UserId,\r\n    name: String where _.length >= 2,\r\n    email: Email,\r\n    createdAt: DateTime,\r\n  };\r\n  type ApiError = { code: Int, message: String };\r\n}\r\n\r\nfunc toEmail(s: String): Result<Email, String> {\r\n  if matches(\"^[^@]+@[^@]+\\\\.[^@]+$\", s) {\r\n    return Ok(brand<Email>(s));\r\n  } else {\r\n    return Err(\"Invalid email\");\r\n  }\r\n}\r\n\r\neffect createUser(input: { name: String, email: Email }): Result<User, ApiError> uses http, clock {\r\n  return http.post(\"/users\", {\r\n    name: input.name,\r\n    email: input.email,\r\n    createdAt: clock.now(),\r\n  });\r\n}\r\n","transpiled_py":"from __future__ import annotations\n# Generated by IntentLang\n# DO NOT EDIT MANUALLY\n\nfrom dataclasses import dataclass\nfrom typing import NewType\nfrom datetime import datetime\nfrom ._prelude import Http, Clock, Result, Ok, Err\n\nEmail = NewType(\"Email\", str)\nUserId = str\n\n@dataclass\nclass User:\n    id: UserId\n    name: str\n    email: Email\n    createdAt: datetime\n\n@dataclass\nclass ApiError:\n    code: int\n    message: str\n\ndef toEmail(s: str) -> Result[Email, str]:\n    return Ok(Email(s)) if \"@\" in s else Err(\"Invalid email\")\n\nasync def createUser(\n    deps,  # e.g. {\"http\": Http, \"clock\": Clock}\n    input: object,  # e.g. {\"name\": str, \"email\": Email}\n) -> Result[User, ApiError]:\n    assert hasattr(input, \"name\") and len(getattr(input, \"name\")) >= 2, \"Precondition failed\"\n    return Err(ApiError(code=501, message=\"Not implemented\"))\n","ast":null}
